{"version":3,"file":"functions.cjs","sources":["../src/utils.ts","../src/center.ts","../src/list-node-scenes.ts","../src/clear-node-parent.ts","../../../node_modules/gl-matrix/esm/common.js","../../../node_modules/gl-matrix/esm/mat4.js","../../../node_modules/gl-matrix/esm/vec3.js","../../../node_modules/gl-matrix/esm/vec4.js","../src/dedup.ts","../src/get-texture-color-space.ts","../src/list-texture-info.ts","../src/list-texture-slots.ts","../src/prune.ts","../src/weld.ts","../src/clean-primitive.ts","../src/transform-primitive.ts","../../../node_modules/gl-matrix/esm/mat3.js","../src/transform-mesh.ts","../src/clear-node-transform.ts","../src/dequantize.ts","../src/draco.ts","../src/flatten.ts","../src/inspect.ts","../src/instance.ts","../src/join-primitives.ts","../src/join.ts","../src/list-texture-channels.ts","../src/reorder.ts","../src/sort-primitive-weights.ts","../src/quantize.ts","../src/meshopt.ts","../src/metal-rough.ts","../src/unweld.ts","../src/normals.ts","../src/palette.ts","../src/partition.ts","../../../node_modules/keyframe-resample/dist/keyframe-resample-browser.modern.js","../src/resample.ts","../src/sequence.ts","../src/simplify.ts","../src/sparse.ts","../src/texture-resize.ts","../src/texture-compress.ts","../src/tangents.ts","../src/unpartition.ts","../src/vertex-color-space.ts","../src/get-node-scene.ts","../src/unlit.ts"],"sourcesContent":["import type { NdArray } from 'ndarray';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport {\n\tAccessor,\n\tDocument,\n\tPrimitive,\n\tProperty,\n\tPropertyType,\n\tTexture,\n\tTransform,\n\tTransformContext,\n\tvec2,\n} from '@gltf-transform/core';\n\n/**\n * Prepares a function used in an {@link Document.transform} pipeline. Use of this wrapper is\n * optional, and plain functions may be used in transform pipelines just as well. The wrapper is\n * used internally so earlier pipeline stages can detect and optimize based on later stages.\n * @hidden\n */\nexport function createTransform(name: string, fn: Transform): Transform {\n\tObject.defineProperty(fn, 'name', { value: name });\n\treturn fn;\n}\n\n/** @hidden */\nexport function isTransformPending(context: TransformContext | undefined, initial: string, pending: string): boolean {\n\tif (!context) return false;\n\tconst initialIndex = context.stack.lastIndexOf(initial);\n\tconst pendingIndex = context.stack.lastIndexOf(pending);\n\treturn initialIndex < pendingIndex;\n}\n\n/**\n * Maps pixels from source to target textures, with a per-pixel callback.\n * @hidden\n */\nexport async function rewriteTexture(\n\tsource: Texture,\n\ttarget: Texture,\n\tfn: (pixels: NdArray, i: number, j: number) => void,\n): Promise<Texture | null> {\n\tif (!source) return null;\n\n\tconst srcImage = source.getImage();\n\tif (!srcImage) return null;\n\n\tconst pixels = await getPixels(srcImage, source.getMimeType());\n\n\tfor (let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor (let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst dstImage = await savePixels(pixels, 'image/png');\n\treturn target.setImage(dstImage).setMimeType('image/png');\n}\n\n/** @hidden */\nexport function getGLPrimitiveCount(prim: Primitive): number {\n\tconst indices = prim.getIndices();\n\tconst position = prim.getAttribute('POSITION')!;\n\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase Primitive.Mode.POINTS:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINES:\n\t\t\treturn indices ? indices.getCount() / 2 : position.getCount() / 2;\n\t\tcase Primitive.Mode.LINE_LOOP:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINE_STRIP:\n\t\t\treturn position.getCount() - 1;\n\t\tcase Primitive.Mode.TRIANGLES:\n\t\t\treturn indices ? indices.getCount() / 3 : position.getCount() / 3;\n\t\tcase Primitive.Mode.TRIANGLE_STRIP:\n\t\tcase Primitive.Mode.TRIANGLE_FAN:\n\t\t\treturn position.getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\n/** @hidden */\nexport class SetMap<K, V> {\n\tprivate _map = new Map<K, Set<V>>();\n\tpublic get size(): number {\n\t\treturn this._map.size;\n\t}\n\tpublic has(k: K): boolean {\n\t\treturn this._map.has(k);\n\t}\n\tpublic add(k: K, v: V): this {\n\t\tlet entry = this._map.get(k);\n\t\tif (!entry) {\n\t\t\tentry = new Set();\n\t\t\tthis._map.set(k, entry);\n\t\t}\n\t\tentry.add(v);\n\t\treturn this;\n\t}\n\tpublic get(k: K): Set<V> {\n\t\treturn this._map.get(k) || new Set();\n\t}\n\tpublic keys(): Iterable<K> {\n\t\treturn this._map.keys();\n\t}\n}\n\n/** @hidden */\nexport function formatBytes(bytes: number, decimals = 2): string {\n\tif (bytes === 0) return '0 Bytes';\n\n\tconst k = 1000;\n\tconst dm = decimals < 0 ? 0 : decimals;\n\tconst sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\n/** @hidden */\nexport function formatLong(x: number): string {\n\treturn x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n\n/** @hidden */\nexport function formatDelta(a: number, b: number, decimals = 2): string {\n\tconst prefix = a > b ? '–' : '+';\n\tconst suffix = '%';\n\treturn prefix + ((Math.abs(a - b) / a) * 100).toFixed(decimals) + suffix;\n}\n\n/** @hidden */\nexport function formatDeltaOp(a: number, b: number) {\n\treturn `${formatLong(a)} → ${formatLong(b)} (${formatDelta(a, b)})`;\n}\n\n/**\n * Returns a list of all unique vertex attributes on the given primitive and\n * its morph targets.\n * @hidden\n */\nexport function deepListAttributes(prim: Primitive): Accessor[] {\n\tconst accessors: Accessor[] = [];\n\n\tfor (const attribute of prim.listAttributes()) {\n\t\taccessors.push(attribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const attribute of target.listAttributes()) {\n\t\t\taccessors.push(attribute);\n\t\t}\n\t}\n\n\treturn Array.from(new Set(accessors));\n}\n\n/** @hidden */\nexport function deepSwapAttribute(prim: Primitive, src: Accessor, dst: Accessor): void {\n\tprim.swap(src, dst);\n\tfor (const target of prim.listTargets()) {\n\t\ttarget.swap(src, dst);\n\t}\n}\n\n/** @hidden */\nexport function shallowEqualsArray(a: ArrayLike<unknown> | null, b: ArrayLike<unknown> | null) {\n\tif (a == null && b == null) return true;\n\tif (a == null || b == null) return false;\n\tif (a.length !== b.length) return false;\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) return false;\n\t}\n\treturn true;\n}\n\n/** @hidden */\nexport function remapAttribute(attribute: Accessor, remap: Uint32Array, dstCount: number) {\n\tconst elementSize = attribute.getElementSize();\n\tconst srcCount = attribute.getCount();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = srcArray.slice(0, dstCount * elementSize);\n\n\tfor (let i = 0; i < srcCount; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[remap[i] * elementSize + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray);\n}\n\n/** @hidden */\nexport function createIndices(count: number, maxIndex = count): Uint16Array | Uint32Array {\n\tconst array = maxIndex <= 65534 ? new Uint16Array(count) : new Uint32Array(count);\n\tfor (let i = 0; i < array.length; i++) array[i] = i;\n\treturn array;\n}\n\n/** @hidden */\nexport function isUsed(prop: Property): boolean {\n\treturn prop.listParents().some((parent) => parent.propertyType !== PropertyType.ROOT);\n}\n\n/**\n * Creates a unique key associated with the structure and draw call characteristics of\n * a {@link Primitive}, independent of its vertex content. Helper method, used to\n * identify candidate Primitives for joining.\n * @hidden\n */\nexport function createPrimGroupKey(prim: Primitive): string {\n\tconst document = Document.fromGraph(prim.getGraph())!;\n\tconst material = prim.getMaterial();\n\tconst materialIndex = document.getRoot().listMaterials().indexOf(material!);\n\tconst mode = prim.getMode();\n\tconst indices = !!prim.getIndices();\n\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.sort()\n\t\t.map((semantic) => {\n\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\tconst componentType = attribute.getComponentType();\n\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t})\n\t\t.join('+');\n\n\tconst targets = prim\n\t\t.listTargets()\n\t\t.map((target) => {\n\t\t\treturn target\n\t\t\t\t.listSemantics()\n\t\t\t\t.sort()\n\t\t\t\t.map((semantic) => {\n\t\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\t\t\tconst componentType = attribute.getComponentType();\n\t\t\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t\t\t})\n\t\t\t\t.join('+');\n\t\t})\n\t\t.join('~');\n\n\treturn `${materialIndex}|${mode}|${indices}|${attributes}|${targets}`;\n}\n\n/** @hidden */\nexport function fitWithin(size: vec2, limit: vec2): vec2 {\n\tconst [maxWidth, maxHeight] = limit;\n\tconst [srcWidth, srcHeight] = size;\n\n\tif (srcWidth <= maxWidth && srcHeight <= maxHeight) return size;\n\n\tlet dstWidth = srcWidth;\n\tlet dstHeight = srcHeight;\n\n\tif (dstWidth > maxWidth) {\n\t\tdstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n\t\tdstWidth = maxWidth;\n\t}\n\n\tif (dstHeight > maxHeight) {\n\t\tdstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n\t\tdstHeight = maxHeight;\n\t}\n\n\treturn [dstWidth, dstHeight];\n}\n","import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { getBounds } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'center';\n\n/** Options for the {@link center} function. */\nexport interface CenterOptions {\n\t/** Location on the model to be considered the pivot, and recentered at the origin. */\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst CENTER_DEFAULTS: Required<CenterOptions> = { pivot: 'center' };\n\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n *\n * @category Transforms\n */\nexport function center(_options: CenterOptions = CENTER_DEFAULTS): Transform {\n\tconst options = { ...CENTER_DEFAULTS, ..._options } as Required<CenterOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot()\n\t\t\t.listScenes()\n\t\t\t.forEach((scene, index) => {\n\t\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\t\tlet pivot: vec3;\n\t\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\t\tconst bbox = getBounds(scene);\n\t\t\t\t\tpivot = [\n\t\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t\t];\n\t\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t\t} else {\n\t\t\t\t\tpivot = options.pivot as vec3;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\t\tif (isAnimated) {\n\t\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\t\tscene.addChild(offsetNode);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\t\tchild.setTranslation([t[0] + offset[0], t[1] + offset[1], t[2] + offset[2]]);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import { Node, Scene } from '@gltf-transform/core';\n\n/**\n * Finds the parent {@link Scene Scenes} associated with the given {@link Node}.\n * In most cases a Node is associated with only one Scene, but it is possible\n * for a Node to be located in two or more Scenes, or none at all.\n *\n * Example:\n *\n * ```typescript\n * import { listNodeScenes } from '@gltf-transform/functions';\n *\n * const node = document.getRoot().listNodes()\n *  .find((node) => node.getName() === 'MyNode');\n *\n * const scenes = listNodeScenes(node);\n * ```\n */\nexport function listNodeScenes(node: Node): Scene[] {\n\tconst visited = new Set<Node>();\n\n\tlet child = node;\n\tlet parent: Node | null;\n\n\twhile ((parent = child.getParentNode() as Node | null)) {\n\t\tif (visited.has(parent)) {\n\t\t\tthrow new Error('Circular dependency in scene graph.');\n\t\t}\n\t\tvisited.add(parent);\n\t\tchild = parent;\n\t}\n\n\treturn child.listParents().filter((parent) => parent instanceof Scene) as Scene[];\n}\n","import type { Node } from '@gltf-transform/core';\nimport { listNodeScenes } from './list-node-scenes.js';\n\n/**\n * Clears the parent of the given {@link Node}, leaving it attached\n * directly to its {@link Scene}. Inherited transforms will be applied\n * to the Node. This operation changes the Node's local transform,\n * but leaves its world transform unchanged.\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeParent } from '@gltf-transform/functions';\n *\n * scene.traverse((node) => { ... }); // Scene → … → Node\n *\n * clearNodeParent(node);\n *\n * scene.traverse((node) => { ... }); // Scene → Node\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeParent(node: Node): Node {\n\tconst scenes = listNodeScenes(node);\n\tconst parent = node.getParentNode();\n\n\tif (!parent) return node;\n\n\t// Apply inherited transforms to local matrix. Skinned meshes are not affected\n\t// by the node parent's transform, and can be ignored. Updates to IBMs and TRS\n\t// animations are out of scope in this context.\n\tnode.setMatrix(node.getWorldMatrix());\n\n\t// Add to Scene roots.\n\tparent.removeChild(node);\n\tfor (const scene of scenes) scene.addChild(node);\n\n\treturn node;\n}\n","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","import {\n\tAccessor,\n\tBufferUtils,\n\tDocument,\n\tMaterial,\n\tMesh,\n\tPrimitive,\n\tPrimitiveTarget,\n\tProperty,\n\tPropertyType,\n\tRoot,\n\tSkin,\n\tTexture,\n\tTransform,\n} from '@gltf-transform/core';\nimport { createTransform, shallowEqualsArray } from './utils.js';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\t/** Keep properties with unique names, even if they are duplicates. */\n\tkeepUniqueNames?: boolean;\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n}\n\nconst DEDUP_DEFAULTS: Required<DedupOptions> = {\n\tkeepUniqueNames: false,\n\tpropertyTypes: [\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.MESH,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.SKIN,\n\t],\n};\n\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, {@link Texture}, and {@link Material}\n * properties. Partially based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8). Only\n * accessors in mesh primitives, morph targets, and animation samplers are processed.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); // → [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); // → [Mesh]\n * ```\n *\n * @category Transforms\n */\nexport function dedup(_options: DedupOptions = DEDUP_DEFAULTS): Transform {\n\tconst options = { ...DEDUP_DEFAULTS, ..._options } as Required<DedupOptions>;\n\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tfor (const propertyType of options.propertyTypes) {\n\t\tif (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n\t\t\tthrow new Error(`${NAME}: Unsupported deduplication on type \"${propertyType}\".`);\n\t\t}\n\t}\n\n\treturn createTransform(NAME, (document: Document): void => {\n\t\tconst logger = document.getLogger();\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(document);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(document, options);\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) dedupMaterials(document, options);\n\t\tif (propertyTypes.has(PropertyType.MESH)) dedupMeshes(document, options);\n\t\tif (propertyTypes.has(PropertyType.SKIN)) dedupSkins(document, options);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction dedupAccessors(document: Document): void {\n\tconst logger = document.getLogger();\n\n\t// Find all accessors used for mesh and animation data.\n\tconst indicesMap = new Map<string, Set<Accessor>>();\n\tconst attributeMap = new Map<string, Set<Accessor>>();\n\tconst inputMap = new Map<string, Set<Accessor>>();\n\tconst outputMap = new Map<string, Set<Accessor>>();\n\n\tconst meshes = document.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => hashAccessor(accessor, attributeMap));\n\t\t\thashAccessor(primitive.getIndices(), indicesMap);\n\t\t});\n\t});\n\n\tfor (const animation of document.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\thashAccessor(sampler.getInput(), inputMap);\n\t\t\thashAccessor(sampler.getOutput(), outputMap);\n\t\t}\n\t}\n\n\t// Add accessor to the appropriate hash group. Hashes are _non-unique_,\n\t// intended to quickly compare everything accept the underlying array.\n\tfunction hashAccessor(accessor: Accessor | null, group: Map<string, Set<Accessor>>): void {\n\t\tif (!accessor) return;\n\n\t\tconst hash = [\n\t\t\taccessor.getCount(),\n\t\t\taccessor.getType(),\n\t\t\taccessor.getComponentType(),\n\t\t\taccessor.getNormalized(),\n\t\t\taccessor.getSparse(),\n\t\t].join(':');\n\n\t\tlet hashSet = group.get(hash);\n\t\tif (!hashSet) group.set(hash, (hashSet = new Set<Accessor>()));\n\t\thashSet.add(accessor);\n\t}\n\n\t// Find duplicate accessors of a given type.\n\tfunction detectDuplicates(accessors: Accessor[], duplicates: Map<Accessor, Accessor>): void {\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = BufferUtils.toView(a.getArray()!);\n\n\t\t\tif (duplicates.has(a)) continue;\n\n\t\t\tfor (let j = i + 1; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t\t// Just compare the arrays — everything else was covered by the\n\t\t\t\t// hash. Comparing uint8 views is faster than comparing the\n\t\t\t\t// original typed arrays.\n\t\t\t\tif (BufferUtils.equals(aData, BufferUtils.toView(b.getArray()!))) {\n\t\t\t\t\tduplicates.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlet total = 0;\n\tconst duplicates = new Map<Accessor, Accessor>();\n\tfor (const group of [attributeMap, indicesMap, inputMap, outputMap]) {\n\t\tfor (const hashGroup of group.values()) {\n\t\t\ttotal += hashGroup.size;\n\t\t\tdetectDuplicates(Array.from(hashGroup), duplicates);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${total} accessors.`);\n\n\t// Dissolve duplicate vertex attributes and indices.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicates.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicates.get(accessor) as Accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicates.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicates.get(indices) as Accessor);\n\t\t\t}\n\t\t});\n\t});\n\n\t// Dissolve duplicate animation sampler inputs and outputs.\n\tfor (const animation of document.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input && duplicates.has(input)) {\n\t\t\t\tsampler.swap(input, duplicates.get(input) as Accessor);\n\t\t\t}\n\t\t\tif (output && duplicates.has(output)) {\n\t\t\t\tsampler.swap(output, duplicates.get(output) as Accessor);\n\t\t\t}\n\t\t}\n\t}\n\n\tArray.from(duplicates.keys()).forEach((accessor) => accessor.dispose());\n}\n\nfunction dedupMeshes(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\n\t// Create Reference -> ID lookup table.\n\tconst refs = new Map<Accessor | Material, number>();\n\troot.listAccessors().forEach((accessor, index) => refs.set(accessor, index));\n\troot.listMaterials().forEach((material, index) => refs.set(material, index));\n\n\t// For each mesh, create a hashkey.\n\tconst numMeshes = root.listMeshes().length;\n\tconst uniqueMeshes = new Map<string, Mesh>();\n\tfor (const src of root.listMeshes()) {\n\t\t// For each mesh, create a hashkey.\n\t\tconst srcKeyItems = [];\n\t\tfor (const prim of src.listPrimitives()) {\n\t\t\tsrcKeyItems.push(createPrimitiveKey(prim, refs));\n\t\t}\n\n\t\t// If another mesh exists with the same key, replace all instances with that, and dispose\n\t\t// of the duplicate. If not, just cache it.\n\t\tlet meshKey = '';\n\t\tif (options.keepUniqueNames) meshKey += src.getName() + ';';\n\t\tmeshKey += srcKeyItems.join(';');\n\n\t\tif (uniqueMeshes.has(meshKey)) {\n\t\t\tconst targetMesh = uniqueMeshes.get(meshKey)!;\n\t\t\tsrc.listParents().forEach((parent) => {\n\t\t\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\t\t\tparent.swap(src, targetMesh);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsrc.dispose();\n\t\t} else {\n\t\t\tuniqueMeshes.set(meshKey, src);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${numMeshes - uniqueMeshes.size} of ${numMeshes} meshes.`);\n}\n\nfunction dedupImages(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\t// Compare each texture to every other texture — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = i + 1; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\t\t\tif (options.keepUniqueNames && a.getName() !== b.getName()) continue;\n\n\t\t\tconst aSize = a.getSize();\n\t\t\tconst bSize = b.getSize();\n\t\t\tif (!aSize || !bSize) continue;\n\t\t\tif (aSize[0] !== bSize[0]) continue;\n\t\t\tif (aSize[1] !== bSize[1]) continue;\n\t\t\tif (!aData || !bData) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${root.listTextures().length} textures.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupMaterials(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst materials = root.listMaterials();\n\tconst duplicates = new Map<Material, Material>();\n\tconst modifierCache = new Map<Material, boolean>();\n\tconst skip = new Set<string>();\n\n\tif (!options.keepUniqueNames) {\n\t\tskip.add('name');\n\t}\n\n\t// Compare each material to every other material — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < materials.length; i++) {\n\t\tconst a = materials[i];\n\n\t\tif (duplicates.has(a)) continue;\n\t\tif (hasModifier(a, modifierCache)) continue;\n\n\t\tfor (let j = i + 1; j < materials.length; j++) {\n\t\t\tconst b = materials[j];\n\n\t\t\tif (duplicates.has(b)) continue;\n\t\t\tif (hasModifier(b, modifierCache)) continue;\n\n\t\t\tif (a.equals(b, skip)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${materials.length} materials.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupSkins(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst skins = root.listSkins();\n\tconst duplicates = new Map<Skin, Skin>();\n\tconst skip = new Set(['joints']);\n\n\tif (!options.keepUniqueNames) {\n\t\tskip.add('name');\n\t}\n\n\tfor (let i = 0; i < skins.length; i++) {\n\t\tconst a = skins[i];\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = i + 1; j < skins.length; j++) {\n\t\t\tconst b = skins[j];\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// Check joints with shallow equality, not deep equality.\n\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/RecursiveSkeletons\n\t\t\tif (a.equals(b, skip) && shallowEqualsArray(a.listJoints(), b.listJoints())) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${skins.length} skins.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\n/** Generates a key unique to the content of a primitive or target. */\nfunction createPrimitiveKey(prim: Primitive | PrimitiveTarget, refs: Map<Accessor | Material, number>): string {\n\tconst primKeyItems = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tprimKeyItems.push(semantic + ':' + refs.get(attribute));\n\t}\n\tif (prim instanceof Primitive) {\n\t\tconst indices = prim.getIndices();\n\t\tif (indices) {\n\t\t\tprimKeyItems.push('indices:' + refs.get(indices));\n\t\t}\n\t\tconst material = prim.getMaterial();\n\t\tif (material) {\n\t\t\tprimKeyItems.push('material:' + refs.get(material));\n\t\t}\n\t\tprimKeyItems.push('mode:' + prim.getMode());\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tprimKeyItems.push('target:' + createPrimitiveKey(target, refs));\n\t\t}\n\t}\n\treturn primKeyItems.join(',');\n}\n\n/**\n * Detects dependencies modified by a parent reference, to conservatively prevent merging. When\n * implementing extensions like KHR_animation_pointer, the 'modifyChild' attribute should be added\n * to graph edges connecting the animation channel to the animated target property.\n *\n * NOTICE: Implementation is conservative, and could prevent merging two materials sharing the\n * same animated \"Clearcoat\" ExtensionProperty. While that scenario is possible for an in-memory\n * glTF Transform graph, valid glTF input files do not have that risk.\n */\nfunction hasModifier(prop: Property, cache: Map<Property, boolean>): boolean {\n\tif (cache.has(prop)) return cache.get(prop)!;\n\n\tconst graph = prop.getGraph();\n\tconst visitedNodes = new Set<Property>();\n\tconst edgeQueue = graph.listParentEdges(prop);\n\n\t// Search dependency subtree for 'modifyChild' attribute.\n\twhile (edgeQueue.length > 0) {\n\t\tconst edge = edgeQueue.pop()!;\n\t\tif (edge.getAttributes().modifyChild === true) {\n\t\t\tcache.set(prop, true);\n\t\t\treturn true;\n\t\t}\n\n\t\tconst child = edge.getChild();\n\t\tif (visitedNodes.has(child)) continue;\n\n\t\tfor (const childEdge of graph.listChildEdges(child)) {\n\t\t\tedgeQueue.push(childEdge);\n\t\t}\n\t}\n\n\tcache.set(prop, false);\n\treturn false;\n}\n","import { Texture } from '@gltf-transform/core';\n\nconst SRGB_PATTERN = /color|emissive|diffuse/i;\n\n/**\n * Returns the color space (if any) implied by the {@link Material} slots to\n * which a texture is assigned, or null for non-color textures. If the texture\n * is not connected to any {@link Material}, this function will also return\n * null — any metadata in the image file will be ignored.\n *\n * Under current glTF specifications, only 'srgb' and non-color (null) textures\n * are used.\n *\n * Example:\n *\n * ```typescript\n * import { getTextureColorSpace } from '@gltf-transform/functions';\n *\n * const baseColorTexture = material.getBaseColorTexture();\n * const normalTexture = material.getNormalTexture();\n *\n * getTextureColorSpace(baseColorTexture); // → 'srgb'\n * getTextureColorSpace(normalTexture); // → null\n * ```\n */\nexport function getTextureColorSpace(texture: Texture): string | null {\n\tconst graph = texture.getGraph();\n\tconst edges = graph.listParentEdges(texture);\n\tconst isSRGB = edges.some((edge) => {\n\t\treturn edge.getAttributes().isColor || SRGB_PATTERN.test(edge.getName());\n\t});\n\treturn isSRGB ? 'srgb' : null;\n}\n","import { ExtensionProperty, Material, Property, Texture, TextureInfo } from '@gltf-transform/core';\n\n/**\n * Lists all {@link TextureInfo} definitions associated with a given\n * {@link Texture}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * // Find TextureInfo instances associated with the texture.\n * const results = listTextureInfo(texture);\n *\n * // Find which UV sets (TEXCOORD_0, TEXCOORD_1, ...) are required.\n * const texCoords = results.map((info) => info.getTexCoord());\n * // → [0, 1]\n * ```\n */\nexport function listTextureInfo(texture: Texture): TextureInfo[] {\n\tconst graph = texture.getGraph();\n\tconst results = new Set<TextureInfo>();\n\n\tfor (const textureEdge of graph.listParentEdges(texture)) {\n\t\tconst parent = textureEdge.getParent();\n\t\tconst name = textureEdge.getName() + 'Info';\n\n\t\tfor (const edge of graph.listChildEdges(parent)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (child instanceof TextureInfo && edge.getName() === name) {\n\t\t\t\tresults.add(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Array.from(results);\n}\n\n/**\n * Lists all {@link TextureInfo} definitions associated with any {@link Texture}\n * on the given {@link Material}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * const results = listTextureInfoByMaterial(material);\n *\n * const texCoords = results.map((info) => info.getTexCoord());\n * // → [0, 1]\n * ```\n */\nexport function listTextureInfoByMaterial(material: Material): TextureInfo[] {\n\tconst graph = material.getGraph();\n\tconst visited = new Set<Property>();\n\tconst results = new Set<TextureInfo>();\n\n\tfunction traverse(prop: Material | ExtensionProperty) {\n\t\tconst textureInfoNames = new Set<string>();\n\n\t\tfor (const edge of graph.listChildEdges(prop)) {\n\t\t\tif (edge.getChild() instanceof Texture) {\n\t\t\t\ttextureInfoNames.add(edge.getName() + 'Info');\n\t\t\t}\n\t\t}\n\n\t\tfor (const edge of graph.listChildEdges(prop)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (visited.has(child)) continue;\n\t\t\tvisited.add(child);\n\n\t\t\tif (child instanceof TextureInfo && textureInfoNames.has(edge.getName())) {\n\t\t\t\tresults.add(child);\n\t\t\t} else if (child instanceof ExtensionProperty) {\n\t\t\t\ttraverse(child);\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverse(material);\n\treturn Array.from(results);\n}\n","import { Document, Texture } from '@gltf-transform/core';\n\n/**\n * Returns names of all texture slots using the given texture.\n *\n * Example:\n *\n * ```js\n * const slots = listTextureSlots(texture);\n * // → ['occlusionTexture', 'metallicRoughnesTexture']\n * ```\n */\nexport function listTextureSlots(texture: Texture): string[] {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tconst root = document.getRoot();\n\tconst slots = texture\n\t\t.getGraph()\n\t\t.listParentEdges(texture)\n\t\t.filter((edge) => edge.getParent() !== root)\n\t\t.map((edge) => edge.getName());\n\treturn Array.from(new Set(slots));\n}\n","import {\n\tAnimationChannel,\n\tColorUtils,\n\tDocument,\n\tExtensionProperty,\n\tGraph,\n\tILogger,\n\tMaterial,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tProperty,\n\tPropertyType,\n\tRoot,\n\tScene,\n\tTexture,\n\tTextureInfo,\n\tTransform,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { mul as mulVec3 } from 'gl-matrix/vec3';\nimport { add, create, len, mul, scale, sub } from 'gl-matrix/vec4';\nimport { NdArray } from 'ndarray';\nimport { getPixels } from 'ndarray-pixels';\nimport { getTextureColorSpace } from './get-texture-color-space.js';\nimport { listTextureInfoByMaterial } from './list-texture-info.js';\nimport { listTextureSlots } from './list-texture-slots.js';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'prune';\n\nconst EPS = 3 / 255;\n\nexport interface PruneOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n\t/** Whether to keep empty leaf nodes. */\n\tkeepLeaves?: boolean;\n\t/** Whether to keep unused vertex attributes, such as UVs without an assigned texture. */\n\tkeepAttributes?: boolean;\n\t/** Whether to keep redundant mesh indices, where vertex count equals index count. */\n\tkeepIndices?: boolean;\n\t/** Whether to keep single-color textures that can be converted to material factors. */\n\tkeepSolidTextures?: boolean;\n}\nconst PRUNE_DEFAULTS: Required<PruneOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.NODE,\n\t\tPropertyType.SKIN,\n\t\tPropertyType.MESH,\n\t\tPropertyType.CAMERA,\n\t\tPropertyType.PRIMITIVE,\n\t\tPropertyType.PRIMITIVE_TARGET,\n\t\tPropertyType.ANIMATION,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.BUFFER,\n\t],\n\tkeepLeaves: false,\n\tkeepAttributes: true,\n\tkeepIndices: true,\n\tkeepSolidTextures: true,\n};\n\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```javascript\n * document.getRoot().listMaterials(); // → [Material, Material]\n *\n * await document.transform(prune());\n *\n * document.getRoot().listMaterials(); // → [Material]\n * ```\n *\n * Use {@link PruneOptions} to control what content should be pruned. For example, you can preserve\n * empty objects in the scene hierarchy using the option `keepLeaves`.\n *\n * @category Transforms\n */\nexport function prune(_options: PruneOptions = PRUNE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...PRUNE_DEFAULTS, ..._options } as Required<PruneOptions>;\n\tconst propertyTypes = new Set(options.propertyTypes);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\t\tconst graph = document.getGraph();\n\n\t\tconst counter = new DisposeCounter();\n\n\t\t// Prune top-down, so that low-level properties like accessors can be removed if the\n\t\t// properties referencing them are removed.\n\n\t\t// Prune empty Meshes.\n\t\tif (propertyTypes.has(PropertyType.MESH)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tif (mesh.listPrimitives().length > 0) continue;\n\t\t\t\tcounter.dispose(mesh);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.NODE)) {\n\t\t\tif (!options.keepLeaves) {\n\t\t\t\tfor (const scene of root.listScenes()) {\n\t\t\t\t\tnodeTreeShake(graph, scene, counter);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const node of root.listNodes()) {\n\t\t\t\ttreeShake(node, counter);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.SKIN)) {\n\t\t\tfor (const skin of root.listSkins()) {\n\t\t\t\ttreeShake(skin, counter);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MESH)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\ttreeShake(mesh, counter);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.CAMERA)) {\n\t\t\tfor (const camera of root.listCameras()) {\n\t\t\t\ttreeShake(camera, counter);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE, counter);\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE_TARGET)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET, counter);\n\t\t}\n\n\t\t// Prune unused vertex attributes.\n\t\tif (!options.keepAttributes && propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\tconst materialPrims = new Map<Material, Set<Primitive>>();\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\tconst material = prim.getMaterial();\n\t\t\t\t\tconst required = listRequiredSemantics(document, material);\n\t\t\t\t\tconst unused = listUnusedSemantics(prim, required);\n\t\t\t\t\tpruneAttributes(prim, unused);\n\t\t\t\t\tprim.listTargets().forEach((target) => pruneAttributes(target, unused));\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\tmaterialPrims.has(material)\n\t\t\t\t\t\t\t? materialPrims.get(material)!.add(prim)\n\t\t\t\t\t\t\t: materialPrims.set(material, new Set([prim]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const [material, prims] of materialPrims) {\n\t\t\t\tshiftTexCoords(material, Array.from(prims));\n\t\t\t}\n\t\t}\n\n\t\t// Prune unused mesh indices.\n\t\tif (!options.keepIndices && propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\tpruneIndices(prim);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Pruning animations is a bit more complicated:\n\t\t// (1) Remove channels without target nodes.\n\t\t// (2) Remove animations without channels.\n\t\t// (3) Remove samplers orphaned in the process.\n\t\tif (propertyTypes.has(PropertyType.ANIMATION)) {\n\t\t\tfor (const anim of root.listAnimations()) {\n\t\t\t\tfor (const channel of anim.listChannels()) {\n\t\t\t\t\tif (!channel.getTargetNode()) {\n\t\t\t\t\t\tcounter.dispose(channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!anim.listChannels().length) {\n\t\t\t\t\tconst samplers = anim.listSamplers();\n\t\t\t\t\ttreeShake(anim, counter);\n\t\t\t\t\tsamplers.forEach((sampler) => treeShake(sampler, counter));\n\t\t\t\t} else {\n\t\t\t\t\tanim.listSamplers().forEach((sampler) => treeShake(sampler, counter));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) {\n\t\t\troot.listMaterials().forEach((material) => treeShake(material, counter));\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) {\n\t\t\troot.listTextures().forEach((texture) => treeShake(texture, counter));\n\t\t\tif (!options.keepSolidTextures) {\n\t\t\t\tawait pruneSolidTextures(document, counter);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\troot.listAccessors().forEach((accessor) => treeShake(accessor, counter));\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.BUFFER)) {\n\t\t\troot.listBuffers().forEach((buffer) => treeShake(buffer, counter));\n\t\t}\n\n\t\t// TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n\t\t// be a future enhancement, either tracking unlinked properties as if they were connected\n\t\t// to the Graph, or iterating over a property list provided by the Extension. Properties in\n\t\t// use by an Extension are correctly preserved, in the meantime.\n\n\t\tif (!counter.empty()) {\n\t\t\tconst str = counter\n\t\t\t\t.entries()\n\t\t\t\t.map(([type, count]) => `${type} (${count})`)\n\t\t\t\t.join(', ');\n\t\t\tlogger.info(`${NAME}: Removed types... ${str}`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No unused properties found.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**********************************************************************************************\n * Utility for disposing properties and reporting statistics afterward.\n */\n\nclass DisposeCounter {\n\tpublic readonly disposed: Record<string, number> = {};\n\n\tempty(): boolean {\n\t\tfor (const key in this.disposed) return false;\n\t\treturn true;\n\t}\n\n\tentries(): [string, number][] {\n\t\treturn Object.entries(this.disposed);\n\t}\n\n\t/** Records properties disposed by type. */\n\tdispose(prop: Property): void {\n\t\tthis.disposed[prop.propertyType] = this.disposed[prop.propertyType] || 0;\n\t\tthis.disposed[prop.propertyType]++;\n\t\tprop.dispose();\n\t}\n}\n\n/**********************************************************************************************\n * Helper functions for the {@link prune} transform.\n *\n * IMPORTANT: These functions were previously declared in function scope, but\n * broke in the CommonJS build due to a buggy Babel transform. See:\n * https://github.com/donmccurdy/glTF-Transform/issues/1140\n */\n\n/** Disposes of the given property if it is unused. */\nfunction treeShake(prop: Property, counter: DisposeCounter): void {\n\t// Consider a property unused if it has no references from another property, excluding\n\t// types Root and AnimationChannel.\n\tconst parents = prop.listParents().filter((p) => !(p instanceof Root || p instanceof AnimationChannel));\n\tif (!parents.length) {\n\t\tcounter.dispose(prop);\n\t}\n}\n\n/**\n * For property types the Root does not maintain references to, we'll need to search the\n * graph. It's possible that objects may have been constructed without any outbound links,\n * but since they're not on the graph they don't need to be tree-shaken.\n */\nfunction indirectTreeShake(graph: Graph<Property>, propertyType: string, counter: DisposeCounter): void {\n\tfor (const edge of graph.listEdges()) {\n\t\tconst parent = edge.getParent();\n\t\tif (parent.propertyType === propertyType) {\n\t\t\ttreeShake(parent, counter);\n\t\t}\n\t}\n}\n\n/** Iteratively prunes leaf Nodes without contents. */\nfunction nodeTreeShake(graph: Graph<Property>, prop: Node | Scene, counter: DisposeCounter): void {\n\tprop.listChildren().forEach((child) => nodeTreeShake(graph, child, counter));\n\n\tif (prop instanceof Scene) return;\n\n\tconst isUsed = graph.listParentEdges(prop).some((e) => {\n\t\tconst ptype = e.getParent().propertyType;\n\t\treturn ptype !== PropertyType.ROOT && ptype !== PropertyType.SCENE && ptype !== PropertyType.NODE;\n\t});\n\tconst isEmpty = graph.listChildren(prop).length === 0;\n\tif (isEmpty && !isUsed) {\n\t\tcounter.dispose(prop);\n\t}\n}\n\nfunction pruneAttributes(prim: Primitive | PrimitiveTarget, unused: string[]) {\n\tfor (const semantic of unused) {\n\t\tprim.setAttribute(semantic, null);\n\t}\n}\n\nfunction pruneIndices(prim: Primitive) {\n\tconst indices = prim.getIndices();\n\tconst attribute = prim.listAttributes()[0];\n\tif (indices && attribute && indices.getCount() === attribute.getCount()) {\n\t\tprim.setIndices(null);\n\t}\n}\n\n/**\n * Lists vertex attribute semantics that are unused when rendering a given primitive.\n */\nfunction listUnusedSemantics(prim: Primitive | PrimitiveTarget, required: Set<string>): string[] {\n\tconst unused = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (semantic === 'TANGENT' && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('TEXCOORD_') && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('COLOR_') && semantic !== 'COLOR_0') {\n\t\t\tunused.push(semantic);\n\t\t}\n\t}\n\treturn unused;\n}\n\n/**\n * Lists vertex attribute semantics required by a material. Does not include\n * attributes that would be used unconditionally, like POSITION or NORMAL.\n */\nfunction listRequiredSemantics(\n\tdocument: Document,\n\tmaterial: Material | ExtensionProperty | null,\n\tsemantics = new Set<string>(),\n): Set<string> {\n\tif (!material) return semantics;\n\n\tconst graph = document.getGraph();\n\n\tconst edges = graph.listChildEdges(material);\n\tconst textureNames = new Set<string>();\n\n\tfor (const edge of edges) {\n\t\tif (edge.getChild() instanceof Texture) {\n\t\t\ttextureNames.add(edge.getName());\n\t\t}\n\t}\n\n\tfor (const edge of edges) {\n\t\tconst name = edge.getName();\n\t\tconst child = edge.getChild();\n\n\t\tif (child instanceof TextureInfo) {\n\t\t\tif (textureNames.has(name.replace(/Info$/, ''))) {\n\t\t\t\tsemantics.add(`TEXCOORD_${child.getTexCoord()}`);\n\t\t\t}\n\t\t}\n\n\t\tif (child instanceof Texture && name.match(/normalTexture/i)) {\n\t\t\tsemantics.add('TANGENT');\n\t\t}\n\n\t\tif (child instanceof ExtensionProperty) {\n\t\t\tlistRequiredSemantics(document, child, semantics);\n\t\t}\n\n\t\t// TODO(#748): Does KHR_materials_anisotropy imply required vertex attributes?\n\t}\n\n\treturn semantics;\n}\n\n/**\n * Shifts texCoord indices on the given material and primitives assigned to\n * that material, such that indices start at zero and ascend without gaps.\n * Prior to calling this function, the implementation must ensure that:\n * - All TEXCOORD_n attributes on these prims are used by the material.\n * - Material does not require any unavailable TEXCOORD_n attributes.\n *\n * TEXCOORD_n attributes on morph targets are shifted alongside the parent\n * prim, but gaps may remain in their semantic lists.\n */\nfunction shiftTexCoords(material: Material, prims: Primitive[]) {\n\t// Create map from srcTexCoord → dstTexCoord.\n\tconst textureInfoList = listTextureInfoByMaterial(material);\n\tconst texCoordSet = new Set(textureInfoList.map((info: TextureInfo) => info.getTexCoord()));\n\tconst texCoordList = Array.from(texCoordSet).sort();\n\tconst texCoordMap = new Map(texCoordList.map((texCoord, index) => [texCoord, index]));\n\tconst semanticMap = new Map(texCoordList.map((texCoord, index) => [`TEXCOORD_${texCoord}`, `TEXCOORD_${index}`]));\n\n\t// Update material.\n\tfor (const textureInfo of textureInfoList) {\n\t\tconst texCoord = textureInfo.getTexCoord();\n\t\ttextureInfo.setTexCoord(texCoordMap.get(texCoord)!);\n\t}\n\n\t// Update prims.\n\tfor (const prim of prims) {\n\t\tconst semantics = prim\n\t\t\t.listSemantics()\n\t\t\t.filter((semantic) => semantic.startsWith('TEXCOORD_'))\n\t\t\t.sort();\n\t\tupdatePrim(prim, semantics);\n\t\tprim.listTargets().forEach((target) => updatePrim(target, semantics));\n\t}\n\n\tfunction updatePrim(prim: Primitive | PrimitiveTarget, srcSemantics: string[]) {\n\t\tfor (const srcSemantic of srcSemantics) {\n\t\t\tconst uv = prim.getAttribute(srcSemantic);\n\t\t\tif (!uv) continue;\n\n\t\t\tconst dstSemantic = semanticMap.get(srcSemantic)!;\n\t\t\tif (dstSemantic === srcSemantic) continue;\n\n\t\t\tprim.setAttribute(dstSemantic, uv);\n\t\t\tprim.setAttribute(srcSemantic, null);\n\t\t}\n\t}\n}\n\n/**********************************************************************************************\n * Prune solid (single-color) textures.\n */\n\nasync function pruneSolidTextures(document: Document, counter: DisposeCounter): Promise<void> {\n\tconst root = document.getRoot();\n\tconst graph = document.getGraph();\n\tconst logger = document.getLogger();\n\tconst textures = root.listTextures();\n\n\tconst pending = textures.map(async (texture) => {\n\t\tconst factor = await getTextureFactor(texture);\n\t\tif (!factor) return;\n\n\t\tif (getTextureColorSpace(texture) === 'srgb') {\n\t\t\tColorUtils.convertSRGBToLinear(factor, factor);\n\t\t}\n\n\t\tconst name = texture.getName() || texture.getURI();\n\t\tconst size = texture.getSize()?.join('x');\n\t\tconst slots = listTextureSlots(texture);\n\n\t\tfor (const edge of graph.listParentEdges(texture)) {\n\t\t\tconst parent = edge.getParent();\n\t\t\tif (parent !== root && applyMaterialFactor(parent as Material, factor, edge.getName(), logger)) {\n\t\t\t\tedge.dispose();\n\t\t\t}\n\t\t}\n\n\t\tif (texture.listParents().length === 1) {\n\t\t\tcounter.dispose(texture);\n\t\t\tlogger.debug(`${NAME}: Removed solid-color texture \"${name}\" (${size}px ${slots.join(', ')})`);\n\t\t}\n\t});\n\n\tawait Promise.all(pending);\n}\n\nfunction applyMaterialFactor(\n\tmaterial: Material | ExtensionProperty,\n\tfactor: vec4,\n\tslot: string,\n\tlogger: ILogger,\n): boolean {\n\tif (material instanceof Material) {\n\t\tswitch (slot) {\n\t\t\tcase 'baseColorTexture':\n\t\t\t\tmaterial.setBaseColorFactor(mul(factor, factor, material.getBaseColorFactor()) as vec4);\n\t\t\t\treturn true;\n\t\t\tcase 'emissiveTexture':\n\t\t\t\tmaterial.setEmissiveFactor(\n\t\t\t\t\tmulVec3([0, 0, 0], factor.slice(0, 3) as vec3, material.getEmissiveFactor()) as vec3,\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\tcase 'occlusionTexture':\n\t\t\t\treturn Math.abs(factor[0] - 1) <= EPS;\n\t\t\tcase 'metallicRoughnessTexture':\n\t\t\t\tmaterial.setRoughnessFactor(factor[1] * material.getRoughnessFactor());\n\t\t\t\tmaterial.setMetallicFactor(factor[2] * material.getMetallicFactor());\n\t\t\t\treturn true;\n\t\t\tcase 'normalTexture':\n\t\t\t\treturn len(sub(create(), factor, [0.5, 0.5, 1, 1])) <= EPS;\n\t\t}\n\t}\n\n\tlogger.warn(`${NAME}: Detected single-color ${slot} texture. Pruning ${slot} not yet supported.`);\n\treturn false;\n}\n\nasync function getTextureFactor(texture: Texture): Promise<vec4 | null> {\n\tconst pixels = await maybeGetPixels(texture);\n\tif (!pixels) return null;\n\n\tconst min: vec4 = [Infinity, Infinity, Infinity, Infinity];\n\tconst max: vec4 = [-Infinity, -Infinity, -Infinity, -Infinity];\n\tconst target: vec4 = [0, 0, 0, 0];\n\n\tconst [width, height] = pixels.shape;\n\n\tfor (let i = 0; i < width; i++) {\n\t\tfor (let j = 0; j < height; j++) {\n\t\t\tfor (let k = 0; k < 4; k++) {\n\t\t\t\tmin[k] = Math.min(min[k], pixels.get(i, j, k));\n\t\t\t\tmax[k] = Math.max(max[k], pixels.get(i, j, k));\n\t\t\t}\n\t\t}\n\n\t\tif (len(sub(target, max, min)) / 255 > EPS) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn scale(target, add(target, max, min), 0.5 / 255) as vec4;\n}\n\nasync function maybeGetPixels(texture: Texture): Promise<NdArray<Uint8Array> | null> {\n\ttry {\n\t\treturn await getPixels(texture.getImage()!, texture.getMimeType());\n\t} catch (e) {\n\t\treturn null;\n\t}\n}\n","import {\n\tAccessor,\n\tDocument,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tTransform,\n\tTypedArray,\n\tvec3,\n} from '@gltf-transform/core';\nimport { cleanPrimitive } from './clean-primitive.js';\nimport { dedup } from './dedup.js';\nimport { prune } from './prune.js';\nimport { createIndices, createTransform, formatDeltaOp } from './utils.js';\n\n// DEVELOPER NOTES: Ideally a weld() implementation should be fast, robust,\n// and tunable. The writeup below tracks my attempts to solve for these\n// constraints.\n//\n// (Approach #1) Follow the mergeVertices() implementation of three.js,\n// hashing vertices with a string concatenation of all vertex attributes.\n// The approach does not allow per-attribute tolerance in local units.\n//\n// (Approach #2) Sort points along the X axis, then make cheaper\n// searches up/down the sorted list for merge candidates. While this allows\n// simpler comparison based on specified tolerance, it's much slower, even\n// for cases where choice of the X vs. Y or Z axes is reasonable.\n//\n// (Approach #3) Attempted a Delaunay triangulation in three dimensions,\n// expecting it would be an n * log(n) algorithm, but the only implementation\n// I found (with delaunay-triangulate) appeared to be much slower than that,\n// and was notably slower than the sort-based approach, just building the\n// Delaunay triangulation alone.\n//\n// (Approach #4) Hybrid of (1) and (2), assigning vertices to a spatial\n// grid, then searching the local neighborhood (27 cells) for weld candidates.\n//\n// RESULTS: For the \"Lovecraftian\" sample model, after joining, a primitive\n// with 873,000 vertices can be welded down to 230,000 vertices. Results:\n// - (1) Not tested, but prior results suggest not robust enough.\n// - (2) 30 seconds\n// - (3) 660 seconds\n// - (4) 5 seconds exhaustive, 1.5s non-exhaustive\n\nconst NAME = 'weld';\n\nconst Tolerance = {\n\tDEFAULT: 0.0001,\n\tTEXCOORD: 0.0001, // [0, 1]\n\tCOLOR: 0.01, // [0, 1]\n\tNORMAL: 0.05, // [-1, 1], ±3º\n\tJOINTS: 0.0, // [0, ∞]\n\tWEIGHTS: 0.01, // [0, ∞]\n};\n\n/** Options for the {@link weld} function. */\nexport interface WeldOptions {\n\t/** Tolerance for vertex positions, as a fraction of primitive AABB. */\n\ttolerance?: number;\n\t/** Tolerance for vertex normals, in radians. */\n\ttoleranceNormal?: number;\n\t/** Whether to overwrite existing indices. */\n\toverwrite?: boolean;\n\t/** Enables a more thorough, but slower, search for vertices to weld. */\n\texhaustive?: boolean;\n}\n\nexport const WELD_DEFAULTS: Required<WeldOptions> = {\n\ttolerance: Tolerance.DEFAULT,\n\ttoleranceNormal: Tolerance.NORMAL,\n\toverwrite: true,\n\texhaustive: false, // donmccurdy/glTF-Transform#886\n};\n\n/**\n * Index {@link Primitive Primitives} and (optionally) merge similar vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU can sometimes use the vertex cache more efficiently.\n *\n * When welding, the 'tolerance' threshold determines which vertices qualify for\n * welding based on distance between the vertices as a fraction of the primitive's\n * bounding box (AABB). For example, tolerance=0.01 welds vertices within +/-1%\n * of the AABB's longest dimension. Other vertex attributes are also compared\n * during welding, with attribute-specific thresholds. For `tolerance=0`, geometry\n * is indexed in place, without merging.\n *\n * To preserve visual appearance consistently, use low `toleranceNormal` thresholds\n * around 0.1 (±3º). To pre-processing a scene before simplification or LOD creation,\n * use higher thresholds around 0.5 (±30º).\n *\n * Example:\n *\n * ```javascript\n * import { weld } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tweld({ tolerance: 0.001, toleranceNormal: 0.5 })\n * );\n * ```\n *\n * @category Transforms\n */\nexport function weld(_options: WeldOptions = WELD_DEFAULTS): Transform {\n\tconst options = expandWeldOptions(_options);\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tweldPrimitive(doc, prim, options);\n\n\t\t\t\tif (isPrimEmpty(prim)) prim.dispose();\n\t\t\t}\n\n\t\t\tif (mesh.listPrimitives().length === 0) mesh.dispose();\n\t\t}\n\n\t\tif (options.tolerance > 0) {\n\t\t\t// If tolerance is greater than 0, welding may remove a mesh, so we prune\n\t\t\tawait doc.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.NODE],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: false,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tawait doc.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Index a {@link Primitive} and (optionally) weld similar vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU can sometimes use the vertex cache more efficiently.\n *\n * When welding, the 'tolerance' threshold determines which vertices qualify for\n * welding based on distance between the vertices as a fraction of the primitive's\n * bounding box (AABB). For example, tolerance=0.01 welds vertices within +/-1%\n * of the AABB's longest dimension. Other vertex attributes are also compared\n * during welding, with attribute-specific thresholds. For tolerance=0, geometry\n * is indexed in place, without merging.\n *\n * Example:\n *\n * ```javascript\n * import { weldPrimitive } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes()\n * \t.find((mesh) => mesh.getName() === 'Gizmo');\n *\n * for (const prim of mesh.listPrimitives()) {\n *   weldPrimitive(prim, {tolerance: 0.0001});\n * }\n * ```\n *\n * @privateRemarks TODO(v4): Remove the \"Document\" parameter.\n */\nexport function weldPrimitive(\n\ta: Document | Primitive,\n\tb: Primitive | WeldOptions = WELD_DEFAULTS,\n\tc = WELD_DEFAULTS,\n): void {\n\tlet _document: Document;\n\tlet _prim: Primitive;\n\tlet _options: Required<WeldOptions>;\n\tif (a instanceof Primitive) {\n\t\tconst graph = a.getGraph();\n\t\t_document = Document.fromGraph(graph)!;\n\t\t_prim = a;\n\t\t_options = expandWeldOptions(b as WeldOptions);\n\t} else {\n\t\t_document = a;\n\t\t_prim = b as Primitive;\n\t\t_options = expandWeldOptions(c as WeldOptions);\n\t}\n\n\tif (_prim.getIndices() && !_options.overwrite) return;\n\tif (_prim.getMode() === Primitive.Mode.POINTS) return;\n\n\tif (_options.tolerance === 0) {\n\t\t_indexPrimitive(_document, _prim);\n\t} else {\n\t\t_weldPrimitive(_document, _prim, _options);\n\t}\n}\n\n/** @internal Adds indices, if missing. Does not merge vertices. */\nfunction _indexPrimitive(doc: Document, prim: Primitive): void {\n\t// No need to overwrite here, even if options.overwrite=true.\n\tif (prim.getIndices()) return;\n\n\tconst attr = prim.listAttributes()[0];\n\tconst numVertices = attr.getCount();\n\tconst buffer = attr.getBuffer();\n\tconst indices = doc\n\t\t.createAccessor()\n\t\t.setBuffer(buffer)\n\t\t.setType(Accessor.Type.SCALAR)\n\t\t.setArray(createIndices(numVertices));\n\tprim.setIndices(indices);\n}\n\n/** @internal Weld and merge, combining vertices that are similar on all vertex attributes. */\nfunction _weldPrimitive(doc: Document, prim: Primitive, options: Required<WeldOptions>): void {\n\tconst logger = doc.getLogger();\n\n\tconst srcPosition = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices() || doc.createAccessor().setArray(createIndices(srcPosition.getCount()));\n\tconst uniqueIndices = new Uint32Array(new Set(srcIndices.getArray()!)).sort();\n\n\t// (1) Compute per-attribute tolerance and spatial grid for vertices.\n\n\tconst attributeTolerance: Record<string, number> = {};\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tattributeTolerance[semantic] = getAttributeTolerance(semantic, attribute, options);\n\t}\n\n\tlogger.debug(`${NAME}: Tolerance thresholds: ${formatKV(attributeTolerance)}`);\n\n\t// (2) Compare and identify vertices to weld.\n\n\tconst posA: vec3 = [0, 0, 0];\n\tconst posB: vec3 = [0, 0, 0];\n\n\tconst grid = {} as Record<string, number[]>;\n\tconst cellSize = attributeTolerance.POSITION;\n\n\tfor (let i = 0; i < uniqueIndices.length; i++) {\n\t\tsrcPosition.getElement(uniqueIndices[i], posA);\n\t\tconst key = getGridKey(posA, cellSize);\n\t\tgrid[key] = grid[key] || [];\n\t\tgrid[key].push(uniqueIndices[i]);\n\t}\n\n\t// (2) Compare and identify vertices to weld.\n\n\tconst srcMaxIndex = uniqueIndices[uniqueIndices.length - 1];\n\tconst weldMap = createIndices(srcMaxIndex + 1); // oldIndex → oldCommonIndex\n\tconst writeMap = new Array(uniqueIndices.length).fill(-1); // oldIndex → newIndex\n\n\tconst srcVertexCount = srcPosition.getCount();\n\tlet dstVertexCount = 0;\n\n\tfor (let i = 0; i < uniqueIndices.length; i++) {\n\t\tconst a = uniqueIndices[i];\n\t\tsrcPosition.getElement(a, posA);\n\n\t\tconst cellKeys = options.exhaustive ? getGridNeighborhoodKeys(posA, cellSize) : [getGridKey(posA, cellSize)];\n\n\t\tcells: for (const cellKey of cellKeys) {\n\t\t\tif (!grid[cellKey]) continue cells; // May occur in exhaustive search.\n\n\t\t\tneighbors: for (const j of grid[cellKey]) {\n\t\t\t\tconst b = weldMap[j];\n\n\t\t\t\t// Only weld to lower indices, preventing two-way match.\n\t\t\t\tif (a <= b) continue neighbors;\n\n\t\t\t\tsrcPosition.getElement(b, posB);\n\n\t\t\t\t// Weld if base attributes and morph target attributes match.\n\t\t\t\tconst isBaseMatch = prim.listSemantics().every((semantic) => {\n\t\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\t\tconst tolerance = attributeTolerance[semantic];\n\t\t\t\t\treturn compareAttributes(attribute, a, b, tolerance, semantic);\n\t\t\t\t});\n\t\t\t\tconst isTargetMatch = prim.listTargets().every((target) => {\n\t\t\t\t\treturn target.listSemantics().every((semantic) => {\n\t\t\t\t\t\tconst attribute = target.getAttribute(semantic)!;\n\t\t\t\t\t\tconst tolerance = attributeTolerance[semantic];\n\t\t\t\t\t\treturn compareAttributes(attribute, a, b, tolerance, semantic);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tif (isBaseMatch && isTargetMatch) {\n\t\t\t\t\tweldMap[a] = b;\n\t\t\t\t\tbreak cells;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Output the vertex if we didn't find a match, else record the index of the match. Because\n\t\t// we iterate vertices in ascending order, and only match to lower indices, we're\n\t\t// guaranteed the source vertex for a weld has already been marked for output.\n\t\tif (weldMap[a] === a) {\n\t\t\twriteMap[a] = dstVertexCount++;\n\t\t} else {\n\t\t\twriteMap[a] = writeMap[weldMap[a]];\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t// (3) Update indices.\n\n\tconst dstIndicesCount = srcIndices.getCount(); // # primitives does not change.\n\tconst dstIndicesArray = createIndices(dstIndicesCount, uniqueIndices.length);\n\tfor (let i = 0; i < dstIndicesCount; i++) {\n\t\tdstIndicesArray[i] = writeMap[srcIndices.getScalar(i)];\n\t}\n\tprim.setIndices(srcIndices.clone().setArray(dstIndicesArray));\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\n\t// (4) Update vertex attributes.\n\n\tfor (const srcAttr of prim.listAttributes()) {\n\t\tswapAttributes(prim, srcAttr, writeMap, dstVertexCount);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttr of target.listAttributes()) {\n\t\t\tswapAttributes(target, srcAttr, writeMap, dstVertexCount);\n\t\t}\n\t}\n\n\t// (5) Clean up degenerate triangles.\n\n\tcleanPrimitive(prim);\n}\n\n/** Creates a new TypedArray of the same type as an original, with a new length. */\nfunction createArrayOfType<T extends TypedArray>(array: T, length: number): T {\n\tconst ArrayCtor = array.constructor as new (length: number) => T;\n\treturn new ArrayCtor(length);\n}\n\n/** Replaces an {@link Attribute}, creating a new one with the given elements. */\nfunction swapAttributes(\n\tparent: Primitive | PrimitiveTarget,\n\tsrcAttr: Accessor,\n\treorder: number[],\n\tdstCount: number,\n): void {\n\tconst dstAttrArray = createArrayOfType(srcAttr.getArray()!, dstCount * srcAttr.getElementSize());\n\tconst dstAttr = srcAttr.clone().setArray(dstAttrArray);\n\tconst done = new Uint8Array(dstCount);\n\n\tfor (let i = 0, el = [] as number[]; i < reorder.length; i++) {\n\t\tif (!done[reorder[i]]) {\n\t\t\tdstAttr.setElement(reorder[i], srcAttr.getElement(i, el));\n\t\t\tdone[reorder[i]] = 1;\n\t\t}\n\t}\n\n\tparent.swap(srcAttr, dstAttr);\n\n\t// Clean up.\n\tif (srcAttr.listParents().length === 1) srcAttr.dispose();\n}\n\nconst _a = [] as number[];\nconst _b = [] as number[];\n\n/** Computes a per-attribute tolerance, based on domain and usage of the attribute. */\nfunction getAttributeTolerance(semantic: string, attribute: Accessor, options: Required<WeldOptions>): number {\n\t// Attributes like NORMAL and COLOR_# do not vary in range like POSITION,\n\t// so do not apply the given tolerance factor to these attributes.\n\tif (semantic === 'NORMAL' || semantic === 'TANGENT') return options.toleranceNormal;\n\tif (semantic.startsWith('COLOR_')) return Tolerance.COLOR;\n\tif (semantic.startsWith('TEXCOORD_')) return Tolerance.TEXCOORD;\n\tif (semantic.startsWith('JOINTS_')) return Tolerance.JOINTS;\n\tif (semantic.startsWith('WEIGHTS_')) return Tolerance.WEIGHTS;\n\n\t_a.length = _b.length = 0;\n\tattribute.getMinNormalized(_a);\n\tattribute.getMaxNormalized(_b);\n\tconst diff = _b.map((bi, i) => bi - _a[i]);\n\tconst range = Math.max(...diff);\n\treturn options.tolerance * range;\n}\n\n/** Compares two vertex attributes against a tolerance threshold. */\nfunction compareAttributes(attribute: Accessor, a: number, b: number, tolerance: number, _semantic: string): boolean {\n\tattribute.getElement(a, _a);\n\tattribute.getElement(b, _b);\n\tfor (let i = 0, il = attribute.getElementSize(); i < il; i++) {\n\t\tif (Math.abs(_a[i] - _b[i]) > tolerance) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction formatKV(kv: Record<string, unknown>): string {\n\treturn Object.entries(kv)\n\t\t.map(([k, v]) => `${k}=${v}`)\n\t\t.join(', ');\n}\n\n// Order to search nearer cells first.\nconst CELL_OFFSETS = [0, -1, 1];\n\nfunction getGridNeighborhoodKeys(p: vec3, cellSize: number): string[] {\n\tconst keys = [] as string[];\n\tconst _p = [0, 0, 0] as vec3;\n\tfor (const i of CELL_OFFSETS) {\n\t\tfor (const j of CELL_OFFSETS) {\n\t\t\tfor (const k of CELL_OFFSETS) {\n\t\t\t\t_p[0] = p[0] + i * cellSize;\n\t\t\t\t_p[1] = p[1] + j * cellSize;\n\t\t\t\t_p[2] = p[2] + k * cellSize;\n\t\t\t\tkeys.push(getGridKey(_p, cellSize));\n\t\t\t}\n\t\t}\n\t}\n\treturn keys;\n}\n\nfunction getGridKey(p: vec3, cellSize: number): string {\n\tconst cellX = Math.round(p[0] / cellSize);\n\tconst cellY = Math.round(p[1] / cellSize);\n\tconst cellZ = Math.round(p[2] / cellSize);\n\treturn cellX + ':' + cellY + ':' + cellZ;\n}\n\nfunction expandWeldOptions(_options: WeldOptions): Required<WeldOptions> {\n\tconst options = { ...WELD_DEFAULTS, ..._options } as Required<WeldOptions>;\n\n\tif (options.tolerance < 0 || options.tolerance > 0.1) {\n\t\tthrow new Error(`${NAME}: Requires 0 <= tolerance <= 0.1`);\n\t}\n\n\tif (options.toleranceNormal < 0 || options.toleranceNormal > Math.PI / 2) {\n\t\tthrow new Error(`${NAME}: Requires 0 <= toleranceNormal <= ${(Math.PI / 2).toFixed(2)}`);\n\t}\n\n\tif (options.tolerance > 0) {\n\t\toptions.tolerance = Math.max(options.tolerance, Number.EPSILON);\n\t\toptions.toleranceNormal = Math.max(options.toleranceNormal, Number.EPSILON);\n\t}\n\n\treturn options;\n}\n\n/**\n * For purposes of welding, we consider a primitive to be 'empty' or degenerate\n * if (1) it has an index, and (2) that index is empty. In some cases\n * (mode=POINTS) the index may be missing — this is outside the scope of welding.\n */\nfunction isPrimEmpty(prim: Primitive): boolean {\n\tconst indices = prim.getIndices();\n\treturn !!indices && indices.getCount() === 0;\n}\n","import type { Primitive } from '@gltf-transform/core';\nimport { createIndices } from './utils.js';\n\n/**\n * Removes degenerate triangles from the {@link Primitive}. Any triangle containing fewer than\n * three different vertex indices is considered degenerate. This method does not merge/weld\n * different vertices containing identical data — use {@link weld} first for that purpose.\n *\n * @internal\n */\nexport function cleanPrimitive(prim: Primitive): void {\n\tconst indices = prim.getIndices();\n\tif (!indices) return;\n\n\tconst tmpIndicesArray = [];\n\tlet maxIndex = -Infinity;\n\n\tfor (let i = 0, il = indices.getCount(); i < il; i += 3) {\n\t\tconst a = indices.getScalar(i);\n\t\tconst b = indices.getScalar(i + 1);\n\t\tconst c = indices.getScalar(i + 2);\n\n\t\tif (a === b || a === c || b === c) continue;\n\n\t\ttmpIndicesArray.push(a, b, c);\n\t\tmaxIndex = Math.max(maxIndex, a, b, c);\n\t}\n\n\tconst dstIndicesArray = createIndices(tmpIndicesArray.length, maxIndex);\n\tdstIndicesArray.set(tmpIndicesArray);\n\tindices.setArray(dstIndicesArray);\n}\n","import { vec3, vec4, mat4, Accessor, Primitive } from '@gltf-transform/core';\nimport { create as createMat3, fromMat4, invert, transpose } from 'gl-matrix/mat3';\nimport { create as createVec3, normalize as normalizeVec3, transformMat3, transformMat4 } from 'gl-matrix/vec3';\nimport { create as createVec4 } from 'gl-matrix/vec4';\nimport { createIndices } from './utils.js';\nimport { weldPrimitive } from './weld.js';\nimport { determinant } from 'gl-matrix/mat4';\n\n/**\n * Applies a transform matrix to a {@link Primitive}.\n *\n * When calling {@link transformPrimitive}, any un-masked vertices are overwritten\n * directly in the underlying vertex streams. If streams should be detached instead,\n * see {@link transformMesh}.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformPrimitive } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param prim\n * @param matrix\n * @param skipIndices Vertices, specified by index, to be _excluded_ from the transformation.\n */\nexport function transformPrimitive(prim: Primitive, matrix: mat4, skipIndices = new Set<number>()): void {\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst indices = (prim.getIndices()?.getArray() || createIndices(position!.getCount())) as Uint32Array;\n\n\t// Apply transform to base attributes.\n\tif (position) {\n\t\tapplyMatrix(matrix, position, indices, new Set(skipIndices));\n\t}\n\n\tconst normal = prim.getAttribute('NORMAL');\n\tif (normal) {\n\t\tapplyNormalMatrix(matrix, normal, indices, new Set(skipIndices));\n\t}\n\n\tconst tangent = prim.getAttribute('TANGENT');\n\tif (tangent) {\n\t\tapplyTangentMatrix(matrix, tangent, indices, new Set(skipIndices));\n\t}\n\n\t// Apply transform to morph attributes.\n\tfor (const target of prim.listTargets()) {\n\t\tconst position = target.getAttribute('POSITION');\n\t\tif (position) {\n\t\t\tapplyMatrix(matrix, position, indices, new Set(skipIndices));\n\t\t}\n\n\t\tconst normal = target.getAttribute('NORMAL');\n\t\tif (normal) {\n\t\t\tapplyNormalMatrix(matrix, normal, indices, new Set(skipIndices));\n\t\t}\n\n\t\tconst tangent = target.getAttribute('TANGENT');\n\t\tif (tangent) {\n\t\t\tapplyTangentMatrix(matrix, tangent, indices, new Set(skipIndices));\n\t\t}\n\t}\n\n\t// Reverse winding order if scale is negative.\n\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/NegativeScaleTest\n\tif (determinant(matrix) < 0) {\n\t\treversePrimitiveWindingOrder(prim);\n\t}\n\n\t// Update mask.\n\tfor (let i = 0; i < indices.length; i++) skipIndices.add(indices[i]);\n}\n\nfunction applyMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\t// An arbitrary transform may not keep vertex positions in the required\n\t// range of a normalized attribute. Replace the array, instead.\n\tconst dstArray = new Float32Array(attribute.getCount() * 3);\n\tconst elementSize = attribute.getElementSize();\n\n\tfor (let i = 0, el: number[] = [], il = attribute.getCount(); i < il; i++) {\n\t\tdstArray.set(attribute.getElement(i, el), i * elementSize);\n\t}\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, vector);\n\t\ttransformMat4(vector, vector, matrix);\n\t\tdstArray.set(vector, index * 3);\n\n\t\tskipIndices.add(index);\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n\nfunction applyNormalMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\tconst normalMatrix = createMat3();\n\tfromMat4(normalMatrix, matrix);\n\tinvert(normalMatrix, normalMatrix);\n\ttranspose(normalMatrix, normalMatrix);\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, vector);\n\t\ttransformMat3(vector, vector, normalMatrix);\n\t\tnormalizeVec3(vector, vector);\n\t\tattribute.setElement(index, vector);\n\n\t\tskipIndices.add(index);\n\t}\n}\n\nfunction applyTangentMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\tconst v3 = createVec3() as vec3;\n\tconst v4 = createVec4() as vec4;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, v4);\n\n\t\t// mat4 affine matrix applied to vector, vector interpreted as a direction.\n\t\t// Reference: https://github.com/mrdoob/three.js/blob/9f4de99828c05e71c47e6de0beb4c6e7652e486a/src/math/Vector3.js#L286-L300\n\t\tconst [x, y, z] = v4;\n\t\tv3[0] = matrix[0] * x + matrix[4] * y + matrix[8] * z;\n\t\tv3[1] = matrix[1] * x + matrix[5] * y + matrix[9] * z;\n\t\tv3[2] = matrix[2] * x + matrix[6] * y + matrix[10] * z;\n\t\tnormalizeVec3(v3, v3);\n\n\t\t(v4[0] = v3[0]), (v4[1] = v3[1]), (v4[2] = v3[2]);\n\n\t\tattribute.setElement(index, v4);\n\n\t\tskipIndices.add(index);\n\t}\n}\n\nfunction reversePrimitiveWindingOrder(prim: Primitive) {\n\tif (prim.getMode() !== Primitive.Mode.TRIANGLES) return;\n\tif (!prim.getIndices()) weldPrimitive(prim, { tolerance: 0 });\n\n\tconst indices = prim.getIndices()!;\n\tfor (let i = 0, il = indices.getCount(); i < il; i += 3) {\n\t\tconst a = indices.getScalar(i);\n\t\tconst c = indices.getScalar(i + 2);\n\t\tindices.setScalar(i, c);\n\t\tindices.setScalar(i + 2, a);\n\t}\n}\n","import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;","import { mat4, Accessor, Primitive, Mesh, PropertyType, PrimitiveTarget } from '@gltf-transform/core';\nimport { transformPrimitive } from './transform-primitive.js';\nimport { deepListAttributes } from './utils.js';\n\n/**\n * Applies a transform matrix to every {@link Primitive} in the given {@link Mesh}.\n *\n * Method:\n * - If any primitives are shared by other meshes, they will be detached.\n * - If any vertex streams are shared by primitives of other meshes, vertex data\n *  will be overwritten unless _overwrite=false_ or the indices are masked. If\n * \t_overwrite=false_, a detached copy of the vertex stream is made before applying\n * \tthe transform.\n * - Primitives within the mesh sharing vertex streams will continue to share those streams.\n * - For indexed primitives, only indexed vertices are modified.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformMesh } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformMesh(mesh, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param mesh\n * @param matrix\n * @param overwrite Whether to overwrite vertex streams in place. If false,\n * \t\tstreams shared with other meshes will be detached.\n * @param skipIndices Vertices, specified by index, to be _excluded_ from the transformation.\n */\nexport function transformMesh(mesh: Mesh, matrix: mat4, overwrite = false, skipIndices?: Set<number>): void {\n\t// (1) Detach shared prims.\n\tfor (const srcPrim of mesh.listPrimitives()) {\n\t\tconst isShared = srcPrim.listParents().some((p) => p.propertyType === PropertyType.MESH && p !== mesh);\n\t\tif (isShared) {\n\t\t\tconst dstPrim = srcPrim.clone();\n\t\t\tmesh.swap(srcPrim, dstPrim);\n\n\t\t\tfor (const srcTarget of dstPrim.listTargets()) {\n\t\t\t\tconst dstTarget = srcTarget.clone();\n\t\t\t\tdstPrim.swap(srcTarget, dstTarget);\n\t\t\t}\n\t\t}\n\t}\n\n\t// (2) Detach shared vertex streams.\n\tif (!overwrite) {\n\t\tconst parents = new Set<Primitive | PrimitiveTarget>([\n\t\t\t...mesh.listPrimitives(),\n\t\t\t...mesh.listPrimitives().flatMap((prim) => prim.listTargets()),\n\t\t]);\n\t\tconst attributes = new Map<Accessor, Accessor>();\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\t\t\tconst isShared = srcAttribute\n\t\t\t\t\t.listParents()\n\t\t\t\t\t.some((a) => (a instanceof Primitive || a instanceof PrimitiveTarget) && !parents.has(a));\n\t\t\t\tif (isShared && !attributes.has(srcAttribute)) {\n\t\t\t\t\tattributes.set(srcAttribute, srcAttribute.clone());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const parent of parents) {\n\t\t\tfor (const [srcAttribute, dstAttribute] of attributes) {\n\t\t\t\tparent.swap(srcAttribute, dstAttribute);\n\t\t\t}\n\t\t}\n\t}\n\n\t// (3) Apply transform.\n\tconst attributeSkipIndices = new Map<Accessor, Set<number>>();\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst position = prim.getAttribute('POSITION')!;\n\n\t\tlet primSkipIndices;\n\t\tif (skipIndices) {\n\t\t\tprimSkipIndices = skipIndices;\n\t\t} else if (attributeSkipIndices.has(position)) {\n\t\t\tprimSkipIndices = attributeSkipIndices.get(position)!;\n\t\t} else {\n\t\t\tattributeSkipIndices.set(position, (primSkipIndices = new Set<number>()));\n\t\t}\n\n\t\ttransformPrimitive(prim, matrix, primSkipIndices);\n\t}\n}\n","import { mat4, MathUtils, Node } from '@gltf-transform/core';\nimport { multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { transformMesh } from './transform-mesh.js';\n\n// prettier-ignore\nconst IDENTITY: mat4 = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n\n/**\n * Clears local transform of the {@link Node}, applying the transform to children and meshes.\n *\n * - Applies transform to children\n * - Applies transform to {@link Mesh mesh}\n * - Resets {@link Light lights}, {@link Camera cameras}, and other attachments to the origin\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeTransform } from '@gltf-transform/functions';\n *\n * node.getTranslation(); // → [ 5, 0, 0 ]\n * node.getMesh(); // → vertex data centered at origin\n *\n * clearNodeTransform(node);\n *\n * node.getTranslation(); // → [ 0, 0, 0 ]\n * node.getMesh(); // → vertex data centered at [ 5, 0, 0 ]\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeTransform(node: Node): Node {\n\tconst mesh = node.getMesh();\n\tconst localMatrix = node.getMatrix();\n\n\tif (mesh && !MathUtils.eq(localMatrix, IDENTITY)) {\n\t\ttransformMesh(mesh, localMatrix);\n\t}\n\n\tfor (const child of node.listChildren()) {\n\t\tconst matrix = child.getMatrix();\n\t\tmultiplyMat4(matrix, matrix, localMatrix);\n\t\tchild.setMatrix(matrix);\n\t}\n\n\treturn node.setMatrix(IDENTITY);\n}\n","import type { Accessor, Document, Primitive, Transform } from '@gltf-transform/core';\nimport { KHRMeshQuantization } from '@gltf-transform/extensions';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'dequantize';\n\n/** Options for the {@link dequantize} function. */\nexport interface DequantizeOptions {\n\t/**\n\t * Pattern (regex) used to filter vertex attribute semantics for quantization.\n\t * Default: `/^((?!JOINTS_).)*$/`.\n\t */\n\tpattern?: RegExp;\n}\n\nconst DEQUANTIZE_DEFAULTS: DequantizeOptions = {\n\tpattern: /^((?!JOINTS_).)*$/,\n};\n\n/**\n * Dequantize {@link Primitive Primitives}, removing {@link KHRMeshQuantization `KHR_mesh_quantization`}\n * if present. Dequantization will increase the size of the mesh on disk and in memory, but may be\n * necessary for compatibility with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * await document.transform(dequantize());\n * ```\n *\n * @category Transforms\n */\nexport function dequantize(_options: DequantizeOptions = DEQUANTIZE_DEFAULTS): Transform {\n\tconst options = { ...DEQUANTIZE_DEFAULTS, ..._options } as Required<DequantizeOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tdequantizePrimitive(prim, options);\n\t\t\t}\n\t\t}\n\t\tdoc.createExtension(KHRMeshQuantization).dispose();\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Dequantize a single {@link Primitive}, converting all vertex attributes to float32. Dequantization\n * will increase the size of the mesh on disk and in memory, but may be necessary for compatibility\n * with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes().find((mesh) => mesh.getName() === 'MyMesh');\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tdequantizePrimitive(prim);\n * }\n * ```\n */\nexport function dequantizePrimitive(prim: Primitive, options: Required<DequantizeOptions>): void {\n\tfor (const semantic of prim.listSemantics()) {\n\t\tdequantizeAttribute(semantic, prim.getAttribute(semantic)!, options);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const semantic of target.listSemantics()) {\n\t\t\tdequantizeAttribute(semantic, target.getAttribute(semantic)!, options);\n\t\t}\n\t}\n}\n\nexport function dequantizeAttribute(semantic: string, attribute: Accessor, options: Required<DequantizeOptions>): void {\n\tif (!attribute.getArray()) return;\n\tif (!options.pattern.test(semantic)) return;\n\tif (attribute.getComponentSize() >= 4) return;\n\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\n\tfor (let i = 0, il = attribute.getCount(), el = [] as number[]; i < il; i++) {\n\t\tel = attribute.getElement(i, el);\n\t\tattribute.setArray(dstArray).setElement(i, el).setArray(srcArray);\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRDracoMeshCompression } from '@gltf-transform/extensions';\nimport { createTransform } from './utils.js';\nimport { weld } from './weld.js';\n\nconst NAME = 'draco';\n\nexport interface DracoOptions {\n\tmethod?: 'edgebreaker' | 'sequential';\n\tencodeSpeed?: number;\n\tdecodeSpeed?: number;\n\tquantizePosition?: number;\n\tquantizeNormal?: number;\n\tquantizeColor?: number;\n\tquantizeTexcoord?: number;\n\tquantizeGeneric?: number;\n\tquantizationVolume?: 'mesh' | 'scene';\n}\n\nexport const DRACO_DEFAULTS: DracoOptions = {\n\tmethod: 'edgebreaker',\n\tencodeSpeed: 5,\n\tdecodeSpeed: 5,\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeColor: 8,\n\tquantizeTexcoord: 12,\n\tquantizeGeneric: 12,\n\tquantizationVolume: 'mesh',\n};\n\n/**\n * Applies Draco compression using {@link KHRDracoMeshCompression KHR_draco_mesh_compression}.\n * This type of compression can reduce the size of triangle geometry.\n *\n * This function is a thin wrapper around the {@link KHRDracoMeshCompression} extension itself.\n *\n * @category Transforms\n */\nexport function draco(_options: DracoOptions = DRACO_DEFAULTS): Transform {\n\tconst options = { ...DRACO_DEFAULTS, ..._options } as Required<DracoOptions>;\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tawait document.transform(weld({ tolerance: 0 }));\n\t\tdocument\n\t\t\t.createExtension(KHRDracoMeshCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.method === 'edgebreaker'\n\t\t\t\t\t\t? KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER\n\t\t\t\t\t\t: KHRDracoMeshCompression.EncoderMethod.SEQUENTIAL,\n\t\t\t\tencodeSpeed: options.encodeSpeed,\n\t\t\t\tdecodeSpeed: options.decodeSpeed,\n\t\t\t\tquantizationBits: {\n\t\t\t\t\tPOSITION: options.quantizePosition,\n\t\t\t\t\tNORMAL: options.quantizeNormal,\n\t\t\t\t\tCOLOR: options.quantizeColor,\n\t\t\t\t\tTEX_COORD: options.quantizeTexcoord,\n\t\t\t\t\tGENERIC: options.quantizeGeneric,\n\t\t\t\t},\n\t\t\t\tquantizationVolume: options.quantizationVolume,\n\t\t\t});\n\t});\n}\n","import { Document, Node, PropertyType, Transform } from '@gltf-transform/core';\nimport { clearNodeParent } from './clear-node-parent.js';\nimport { prune } from './prune.js';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'flatten';\n\n/** Options for the {@link flatten} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface FlattenOptions {}\n\nexport const FLATTEN_DEFAULTS: Required<FlattenOptions> = {};\n\n/**\n * Flattens the scene graph, leaving {@link Node Nodes} with\n * {@link Mesh Meshes}, {@link Camera Cameras}, and other attachments\n * as direct children of the {@link Scene}. Skeletons and their\n * descendants are left in their original Node structure.\n *\n * {@link Animation} targeting a Node or its parents will\n * prevent that Node from being moved.\n *\n * Example:\n *\n * ```ts\n * import { flatten } from '@gltf-transform/functions';\n *\n * await document.transform(flatten());\n * ```\n *\n * @category Transforms\n */\nexport function flatten(_options: FlattenOptions = FLATTEN_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...FLATTEN_DEFAULTS, ..._options } as Required<FlattenOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// (1) Mark joints.\n\t\tconst joints = new Set<Node>();\n\t\tfor (const skin of root.listSkins()) {\n\t\t\tfor (const joint of skin.listJoints()) {\n\t\t\t\tjoints.add(joint);\n\t\t\t}\n\t\t}\n\n\t\t// (2) Mark nodes with TRS animation.\n\t\tconst animated = new Set<Node>();\n\t\tfor (const animation of root.listAnimations()) {\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tconst node = channel.getTargetNode();\n\t\t\t\tif (node && channel.getTargetPath() !== 'weights') {\n\t\t\t\t\tanimated.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Mark descendants of joints and animated nodes.\n\t\tconst hasJointParent = new Set<Node>();\n\t\tconst hasAnimatedParent = new Set<Node>();\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst parent = node.getParentNode();\n\t\t\t\tif (!parent) return;\n\t\t\t\tif (joints.has(parent) || hasJointParent.has(parent)) {\n\t\t\t\t\thasJointParent.add(node);\n\t\t\t\t}\n\t\t\t\tif (animated.has(parent) || hasAnimatedParent.has(parent)) {\n\t\t\t\t\thasAnimatedParent.add(node);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// (4) For each affected node, in top-down order, clear parents.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tif (animated.has(node)) return;\n\t\t\t\tif (hasJointParent.has(node)) return;\n\t\t\t\tif (hasAnimatedParent.has(node)) return;\n\n\t\t\t\tclearNodeParent(node);\n\t\t\t});\n\t\t}\n\n\t\t// TODO(feat): Transform animation channels, accounting for previously inherited transforms.\n\t\tif (animated.size) {\n\t\t\tlogger.debug(`${NAME}: Flattening node hierarchies with TRS animation not yet supported.`);\n\t\t}\n\n\t\t// (5) Clean up leaf nodes.\n\t\tawait document.transform(prune({ propertyTypes: [PropertyType.NODE], keepLeaves: false }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import {\n\tAccessor,\n\tDocument,\n\tExtensionProperty,\n\tGLTF,\n\tImageUtils,\n\tTexture,\n\tgetBounds,\n\tPropertyType,\n} from '@gltf-transform/core';\nimport { getGLPrimitiveCount } from './utils.js';\nimport { KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC, read as readKTX } from 'ktx-parse';\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nexport function inspect(doc: Document): InspectReport {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes(doc: Document): InspectPropertyReport<InspectSceneReport> {\n\tconst scenes = doc\n\t\t.getRoot()\n\t\t.listScenes()\n\t\t.map((scene) => {\n\t\t\tconst root = scene.listChildren()[0];\n\t\t\tconst sceneBounds = getBounds(scene);\n\t\t\treturn {\n\t\t\t\tname: scene.getName(),\n\t\t\t\trootName: root ? root.getName() : '',\n\t\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t\t};\n\t\t});\n\treturn { properties: scenes };\n}\n\n/** List meshes. */\nfunction listMeshes(doc: Document): InspectPropertyReport<InspectMeshReport> {\n\tconst meshes: InspectMeshReport[] = doc\n\t\t.getRoot()\n\t\t.listMeshes()\n\t\t.map((mesh) => {\n\t\t\tconst instances = mesh.listParents().filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\t\t\tlet glPrimitives = 0;\n\t\t\tlet verts = 0;\n\t\t\tconst semantics = new Set<string>();\n\t\t\tconst meshIndices = new Set<string>();\n\t\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\t\tconst attr = prim.getAttribute(semantic)!;\n\t\t\t\t\tsemantics.add(semantic + ':' + accessorToTypeLabel(attr));\n\t\t\t\t\tmeshAccessors.add(attr);\n\t\t\t\t}\n\t\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\t\ttarg.listAttributes().forEach((attr) => meshAccessors.add(attr));\n\t\t\t\t}\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tmeshIndices.add(accessorToTypeLabel(indices));\n\t\t\t\t\tmeshAccessors.add(indices);\n\t\t\t\t}\n\t\t\t\tverts += prim.listAttributes()[0].getCount();\n\t\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray()!.byteLength));\n\n\t\t\tconst modes = mesh.listPrimitives().map((prim) => MeshPrimitiveModeLabels[prim.getMode()]);\n\n\t\t\treturn {\n\t\t\t\tname: mesh.getName(),\n\t\t\t\tmode: Array.from(new Set(modes)),\n\t\t\t\tprimitives: mesh.listPrimitives().length,\n\t\t\t\tglPrimitives: glPrimitives,\n\t\t\t\tvertices: verts,\n\t\t\t\tindices: Array.from(meshIndices).sort(),\n\t\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\t\tinstances: instances,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: meshes };\n}\n\n/** List materials. */\nfunction listMaterials(doc: Document): InspectPropertyReport<InspectMaterialReport> {\n\tconst materials: InspectMaterialReport[] = doc\n\t\t.getRoot()\n\t\t.listMaterials()\n\t\t.map((material) => {\n\t\t\tconst instances = material\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\t// Find all texture slots attached to this material or its extensions.\n\t\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listEdges()\n\t\t\t\t.filter((ref) => {\n\t\t\t\t\tconst child = ref.getChild();\n\t\t\t\t\tconst parent = ref.getParent();\n\t\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (child instanceof Texture && parent instanceof ExtensionProperty && extensions.has(parent)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t})\n\t\t\t\t.map((ref) => ref.getName());\n\n\t\t\treturn {\n\t\t\t\tname: material.getName(),\n\t\t\t\tinstances,\n\t\t\t\ttextures: slots,\n\t\t\t\talphaMode: material.getAlphaMode(),\n\t\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t\t};\n\t\t});\n\n\treturn { properties: materials };\n}\n\n/** List textures. */\nfunction listTextures(doc: Document): InspectPropertyReport<InspectTextureReport> {\n\tconst textures: InspectTextureReport[] = doc\n\t\t.getRoot()\n\t\t.listTextures()\n\t\t.map((texture) => {\n\t\t\tconst instances = texture\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listParentEdges(texture)\n\t\t\t\t.filter((edge) => edge.getParent().propertyType !== PropertyType.ROOT)\n\t\t\t\t.map((edge) => edge.getName());\n\n\t\t\tconst resolution = ImageUtils.getSize(texture.getImage()!, texture.getMimeType());\n\n\t\t\tlet compression = '';\n\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\tconst container = readKTX(texture.getImage()!);\n\t\t\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\t\t\tif (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n\t\t\t\t\tcompression = 'ETC1S';\n\t\t\t\t} else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n\t\t\t\t\tcompression = 'UASTC';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname: texture.getName(),\n\t\t\t\turi: texture.getURI(),\n\t\t\t\tslots: Array.from(new Set(slots)),\n\t\t\t\tinstances,\n\t\t\t\tmimeType: texture.getMimeType(),\n\t\t\t\tcompression,\n\t\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\t\tsize: texture.getImage()!.byteLength,\n\t\t\t\tgpuSize: ImageUtils.getVRAMByteLength(texture.getImage()!, texture.getMimeType()),\n\t\t\t};\n\t\t});\n\n\treturn { properties: textures };\n}\n\n/** List animations. */\nfunction listAnimations(doc: Document): InspectPropertyReport<InspectAnimationReport> {\n\tconst animations: InspectAnimationReport[] = doc\n\t\t.getRoot()\n\t\t.listAnimations()\n\t\t.map((anim) => {\n\t\t\tlet minTime = Infinity;\n\t\t\tlet maxTime = -Infinity;\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tif (!input) return;\n\t\t\t\tminTime = Math.min(minTime, input.getMin([])[0]);\n\t\t\t\tmaxTime = Math.max(maxTime, input.getMax([])[0]);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tlet keyframes = 0;\n\t\t\tconst accessors: Set<Accessor> = new Set();\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (!input) return;\n\t\t\t\tkeyframes += input.getCount();\n\t\t\t\taccessors.add(input);\n\t\t\t\tif (!output) return;\n\t\t\t\taccessors.add(output);\n\t\t\t});\n\t\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\t\tsize += accessor.getArray()!.byteLength;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tname: anim.getName(),\n\t\t\t\tchannels: anim.listChannels().length,\n\t\t\t\tsamplers: anim.listSamplers().length,\n\t\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\t\tkeyframes: keyframes,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: animations };\n}\n\nexport interface InspectReport {\n\tscenes: InspectPropertyReport<InspectSceneReport>;\n\tmeshes: InspectPropertyReport<InspectMeshReport>;\n\tmaterials: InspectPropertyReport<InspectMaterialReport>;\n\ttextures: InspectPropertyReport<InspectTextureReport>;\n\tanimations: InspectPropertyReport<InspectAnimationReport>;\n}\n\nexport interface InspectPropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\nexport interface InspectSceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n}\n\nexport interface InspectMeshReport {\n\tname: string;\n\tprimitives: number;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tindices: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\nexport interface InspectMaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\nexport interface InspectTextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tcompression: string;\n\tsize: number;\n\tgpuSize: number | null;\n}\n\nexport interface InspectAnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tkeyframes: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\nconst NumericTypeLabels: Record<string, string> = {\n\tFloat32Array: 'f32',\n\tUint32Array: 'u32',\n\tUint16Array: 'u16',\n\tUint8Array: 'u8',\n\tInt32Array: 'i32',\n\tInt16Array: 'i16',\n\tInt8Array: 'i8',\n};\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif ((v[i] as number).toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n\nfunction accessorToTypeLabel(accessor: Accessor): string {\n\tconst array = accessor.getArray()!;\n\tconst base = NumericTypeLabels[array.constructor.name] || '?';\n\tconst suffix = accessor.getNormalized() ? '_norm' : '';\n\treturn base + suffix;\n}\n","import { Document, ILogger, MathUtils, Mesh, Node, Primitive, Transform, vec3, vec4 } from '@gltf-transform/core';\nimport { InstancedMesh, EXTMeshGPUInstancing } from '@gltf-transform/extensions';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'instance';\n\nexport interface InstanceOptions {\n\t/** Minimum number of meshes considered eligible for instancing. Default: 2. */\n\tmin?: number;\n}\n\nconst INSTANCE_DEFAULTS: Required<InstanceOptions> = {\n\tmin: 2,\n};\n\n/**\n * Creates GPU instances (with `EXT_mesh_gpu_instancing`) for shared {@link Mesh} references. In\n * engines supporting the extension, reused Meshes will be drawn with GPU instancing, greatly\n * reducing draw calls and improving performance in many cases. If you're not sure that identical\n * Meshes share vertex data and materials (\"linked duplicates\"), run {@link dedup} first to link them.\n *\n * Example:\n *\n * ```javascript\n * import { dedup, instance } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup(),\n * \tinstance({min: 2}),\n * );\n * ```\n *\n * @category Transforms\n */\nexport function instance(_options: InstanceOptions = INSTANCE_DEFAULTS): Transform {\n\tconst options = { ...INSTANCE_DEFAULTS, ..._options } as Required<InstanceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tif (root.listAnimations().length) {\n\t\t\tlogger.warn(`${NAME}: Instancing is not currently supported for animated models.`);\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst batchExtension = doc.createExtension(EXTMeshGPUInstancing);\n\n\t\tlet numBatches = 0;\n\t\tlet numInstances = 0;\n\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t// Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n\t\t\tconst meshInstances = new Map<Mesh, Set<Node>>();\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst mesh = node.getMesh();\n\t\t\t\tif (!mesh) return;\n\t\t\t\tmeshInstances.set(mesh, (meshInstances.get(mesh) || new Set<Node>()).add(node));\n\t\t\t});\n\n\t\t\t// For each Mesh, create an InstancedMesh and collect transforms.\n\t\t\tconst modifiedNodes = [];\n\t\t\tfor (const mesh of Array.from(meshInstances.keys())) {\n\t\t\t\tconst nodes = Array.from(meshInstances.get(mesh)!);\n\t\t\t\tif (nodes.length < options.min) continue;\n\t\t\t\tif (nodes.some((node) => node.getSkin())) continue;\n\n\t\t\t\t// Cannot preserve volumetric effects when instancing with varying scale.\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/AttenuationTest\n\t\t\t\tif (mesh.listPrimitives().some(hasVolume) && nodes.some(hasScale)) continue;\n\n\t\t\t\tconst batch = createBatch(doc, batchExtension, mesh, nodes.length);\n\t\t\t\tconst batchTranslation = batch.getAttribute('TRANSLATION')!;\n\t\t\t\tconst batchRotation = batch.getAttribute('ROTATION')!;\n\t\t\t\tconst batchScale = batch.getAttribute('SCALE')!;\n\n\t\t\t\tconst batchNode = doc.createNode().setMesh(mesh).setExtension('EXT_mesh_gpu_instancing', batch);\n\t\t\t\tscene.addChild(batchNode);\n\n\t\t\t\tlet needsTranslation = false;\n\t\t\t\tlet needsRotation = false;\n\t\t\t\tlet needsScale = false;\n\n\t\t\t\t// For each Node, write TRS properties into instance attributes.\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tlet t: vec3, r: vec4, s: vec3;\n\t\t\t\t\tconst node = nodes[i];\n\n\t\t\t\t\tbatchTranslation.setElement(i, (t = node.getWorldTranslation()));\n\t\t\t\t\tbatchRotation.setElement(i, (r = node.getWorldRotation()));\n\t\t\t\t\tbatchScale.setElement(i, (s = node.getWorldScale()));\n\n\t\t\t\t\tif (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n\t\t\t\t\tif (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n\t\t\t\t\tif (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n\n\t\t\t\t\t// Mark the node for cleanup.\n\t\t\t\t\tnode.setMesh(null);\n\t\t\t\t\tmodifiedNodes.push(node);\n\t\t\t\t}\n\n\t\t\t\tif (!needsTranslation) batchTranslation.dispose();\n\t\t\t\tif (!needsRotation) batchRotation.dispose();\n\t\t\t\tif (!needsScale) batchScale.dispose();\n\n\t\t\t\tpruneUnusedNodes(modifiedNodes, logger);\n\n\t\t\t\tnumBatches++;\n\t\t\t\tnumInstances += nodes.length;\n\t\t\t}\n\t\t}\n\n\t\tif (numBatches > 0) {\n\t\t\tlogger.info(`${NAME}: Created ${numBatches} batches, with ${numInstances} total instances.`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No meshes with >=${options.min} parent nodes were found.`);\n\t\t}\n\n\t\tif (batchExtension.listProperties().length === 0) {\n\t\t\tbatchExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction pruneUnusedNodes(nodes: Node[], logger: ILogger): void {\n\tlet node: Node | undefined;\n\tlet unusedNodes = 0;\n\twhile ((node = nodes.pop())) {\n\t\tif (\n\t\t\tnode.listChildren().length ||\n\t\t\tnode.getCamera() ||\n\t\t\tnode.getMesh() ||\n\t\t\tnode.getSkin() ||\n\t\t\tnode.listExtensions().length\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst nodeParent = node.getParentNode();\n\t\tif (nodeParent) nodes.push(nodeParent);\n\t\tnode.dispose();\n\t\tunusedNodes++;\n\t}\n\n\tlogger.debug(`${NAME}: Removed ${unusedNodes} unused nodes.`);\n}\n\nfunction hasVolume(prim: Primitive) {\n\tconst material = prim.getMaterial();\n\treturn !!(material && material.getExtension('KHR_materials_volume'));\n}\n\nfunction hasScale(node: Node) {\n\tconst scale = node.getWorldScale();\n\treturn !MathUtils.eq(scale, [1, 1, 1]);\n}\n\nfunction createBatch(doc: Document, batchExtension: EXTMeshGPUInstancing, mesh: Mesh, count: number): InstancedMesh {\n\tconst buffer = mesh.listPrimitives()[0].getAttribute('POSITION')!.getBuffer();\n\n\tconst batchTranslation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\tconst batchRotation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC4')\n\t\t.setArray(new Float32Array(4 * count))\n\t\t.setBuffer(buffer);\n\tconst batchScale = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\n\treturn batchExtension\n\t\t.createInstancedMesh()\n\t\t.setAttribute('TRANSLATION', batchTranslation)\n\t\t.setAttribute('ROTATION', batchRotation)\n\t\t.setAttribute('SCALE', batchScale);\n}\n","import { Document, Primitive, ComponentTypeToTypedArray } from '@gltf-transform/core';\nimport { createIndices, createPrimGroupKey } from './utils.js';\n\ninterface JoinPrimitiveOptions {\n\tskipValidation?: boolean;\n}\n\nconst JOIN_PRIMITIVE_DEFAULTS: Required<JoinPrimitiveOptions> = {\n\tskipValidation: false,\n};\n\n/**\n * Given a list of compatible Mesh {@link Primitive Primitives}, returns new Primitive\n * containing their vertex data. Compatibility requires that all Primitives share the\n * same {@link Material Materials}, draw mode, and vertex attribute types. Primitives\n * using morph targets cannot currently be joined.\n *\n * Example:\n *\n * ```javascript\n * import { joinPrimitives } from '@gltf-transform/functions';\n *\n * // Succeeds if Primitives are compatible, or throws an error.\n * const result = joinPrimitives(mesh.listPrimitives());\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tprim.dispose();\n * }\n *\n * mesh.addPrimitive(result);\n * ```\n */\nexport function joinPrimitives(prims: Primitive[], options: JoinPrimitiveOptions = {}): Primitive {\n\toptions = { ...JOIN_PRIMITIVE_DEFAULTS, ...options };\n\tconst templatePrim = prims[0]!;\n\tconst document = Document.fromGraph(templatePrim.getGraph())!;\n\n\t// (1) Validation.\n\tif (!options.skipValidation && new Set(prims.map(createPrimGroupKey)).size > 1) {\n\t\tthrow new Error(\n\t\t\t'' +\n\t\t\t\t'Requires >=2 Primitives, sharing the same Material ' +\n\t\t\t\t'and Mode, with compatible vertex attributes and indices.',\n\t\t);\n\t}\n\n\tconst remapList = [] as Uint32Array[]; // remap[srcIndex] → dstIndex, by prim\n\tconst countList = [] as number[]; // vertex count, by prim\n\tconst indicesList = [] as (Uint32Array | Uint16Array)[]; // indices, by prim\n\n\tlet dstVertexCount = 0;\n\tlet dstIndicesCount = 0;\n\n\t// (2) Build remap lists.\n\tfor (const srcPrim of prims) {\n\t\tconst indices = _getOrCreateIndices(srcPrim);\n\t\tconst remap = [];\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < indices.length; i++) {\n\t\t\tconst index = indices[i];\n\t\t\tif (remap[index] === undefined) {\n\t\t\t\tremap[index] = dstVertexCount++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tdstIndicesCount++;\n\t\t}\n\t\tremapList.push(new Uint32Array(remap));\n\t\tcountList.push(count);\n\t\tindicesList.push(indices);\n\t}\n\n\t// (3) Allocate joined attributes.\n\tconst dstPrim = document.createPrimitive().setMode(templatePrim.getMode()).setMaterial(templatePrim.getMaterial());\n\tfor (const semantic of templatePrim.listSemantics()) {\n\t\tconst tplAttribute = templatePrim.getAttribute(semantic)!;\n\t\tconst AttributeArray = ComponentTypeToTypedArray[tplAttribute.getComponentType()];\n\t\tconst dstAttribute = document\n\t\t\t.createAccessor()\n\t\t\t.setType(tplAttribute.getType())\n\t\t\t.setBuffer(tplAttribute.getBuffer())\n\t\t\t.setNormalized(tplAttribute.getNormalized())\n\t\t\t.setArray(new AttributeArray(dstVertexCount * tplAttribute.getElementSize()));\n\t\tdstPrim.setAttribute(semantic, dstAttribute);\n\t}\n\n\t// (4) Allocate joined indices.\n\tconst dstIndicesArray = templatePrim.getIndices() ? createIndices(dstVertexCount) : null;\n\tconst dstIndices =\n\t\tdstIndicesArray &&\n\t\tdocument\n\t\t\t.createAccessor()\n\t\t\t.setBuffer(templatePrim.getIndices()!.getBuffer())\n\t\t\t.setArray(createIndices(dstIndicesCount, dstVertexCount));\n\tdstPrim.setIndices(dstIndices);\n\n\t// (5) Remap attributes into joined Primitive.\n\tlet dstNextIndex = 0;\n\tfor (let primIndex = 0; primIndex < remapList.length; primIndex++) {\n\t\tconst srcPrim = prims[primIndex];\n\t\tconst remap = remapList[primIndex];\n\t\tconst indicesArray = indicesList[primIndex];\n\n\t\tconst primStartIndex = dstNextIndex;\n\t\tlet primNextIndex = primStartIndex;\n\n\t\tfor (const semantic of dstPrim.listSemantics()) {\n\t\t\tconst srcAttribute = srcPrim.getAttribute(semantic)!;\n\t\t\tconst dstAttribute = dstPrim.getAttribute(semantic)!;\n\t\t\tconst el = [] as number[];\n\n\t\t\tprimNextIndex = primStartIndex;\n\t\t\tfor (let i = 0; i < indicesArray.length; i++) {\n\t\t\t\tconst index = indicesArray[i];\n\t\t\t\tsrcAttribute.getElement(index, el);\n\t\t\t\tdstAttribute.setElement(remap[index], el);\n\t\t\t\tif (dstIndices) {\n\t\t\t\t\tdstIndices.setScalar(primNextIndex++, remap[index]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdstNextIndex = primNextIndex;\n\t}\n\n\treturn dstPrim;\n}\n\nfunction _getOrCreateIndices(prim: Primitive): Uint16Array | Uint32Array {\n\tconst indices = prim.getIndices();\n\tif (indices) return indices.getArray() as Uint32Array | Uint16Array;\n\tconst position = prim.getAttribute('POSITION')!;\n\treturn createIndices(position.getCount());\n}\n","import {\n\tAnimationChannel,\n\tDocument,\n\tmat4,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPropertyType,\n\tScene,\n\tTransform,\n} from '@gltf-transform/core';\nimport { invert, multiply } from 'gl-matrix/mat4';\nimport { joinPrimitives } from './join-primitives.js';\nimport { prune } from './prune.js';\nimport { transformPrimitive } from './transform-primitive.js';\nimport { createPrimGroupKey, createTransform, formatLong, isUsed } from './utils.js';\nimport { dequantizeAttribute } from './dequantize.js';\n\nconst NAME = 'join';\n\nconst { ROOT, NODE, MESH, PRIMITIVE, ACCESSOR } = PropertyType;\n\n// prettier-ignore\nconst _matrix = [\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n] as mat4;\n\n/** Options for the {@link join} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JoinOptions {\n\t/**\n\t * Prevents joining distinct {@link Mesh Meshes} and {@link Node Nodes}.\n\t * Joins only Primitives found within the same parent Mesh. To preserve\n\t * only _named_ Nodes and Meshes, use\n\t * {@link JoinOptions.keepNamed keepNamed} instead. Default: false.\n\t */\n\tkeepMeshes: boolean;\n\t/**\n\t * Prevents joining _named_ {@link Mesh Meshes} and {@link Node Nodes}.\n\t * If {@link JoinOptions.keepMeshes keepMeshes} is enabled, keepNamed will\n\t * have no effect. Default: false.\n\t */\n\tkeepNamed: boolean;\n}\n\nexport const JOIN_DEFAULTS: Required<JoinOptions> = {\n\tkeepMeshes: false,\n\tkeepNamed: false,\n};\n\n/**\n * Joins compatible {@link Primitive Primitives} and reduces draw calls.\n * Primitives are eligible for joining if they are members of the same\n * {@link Mesh} or, optionally, attached to sibling {@link Node Nodes}\n * in the scene hierarchy. For best results, apply {@link dedup} and\n * {@link flatten} first to maximize the number of Primitives that\n * can be joined.\n *\n * NOTE: In a Scene that heavily reuses the same Mesh data, joining may\n * increase vertex count. Consider alternatives, like\n * {@link instance instancing} with {@link EXTMeshGPUInstancing}.\n *\n * Example:\n *\n * ```ts\n * import { PropertyType } from '@gltf-transform/core';\n * import { join, flatten, dedup } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup({ propertyTypes: [PropertyType.MATERIAL] }),\n * \tflatten(),\n * \tjoin({ keepNamed: false }),\n * );\n * ```\n *\n * @category Transforms\n */\nexport function join(_options: JoinOptions = JOIN_DEFAULTS): Transform {\n\tconst options = { ...JOIN_DEFAULTS, ..._options } as Required<JoinOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// Join.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t_joinLevel(document, scene, options);\n\t\t\tscene.traverse((node) => _joinLevel(document, node, options));\n\t\t}\n\n\t\t// Clean up.\n\t\tawait document.transform(\n\t\t\tprune({\n\t\t\t\tpropertyTypes: [NODE, MESH, PRIMITIVE, ACCESSOR],\n\t\t\t\tkeepAttributes: true,\n\t\t\t\tkeepIndices: true,\n\t\t\t\tkeepLeaves: false,\n\t\t\t}),\n\t\t);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\ninterface IJoinGroup {\n\tkey: string;\n\tprims: Primitive[];\n\tprimMeshes: Mesh[];\n\tprimNodes: Node[];\n\tdstNode: Node;\n\tdstMesh?: Mesh | undefined;\n}\n\nfunction _joinLevel(document: Document, parent: Node | Scene, options: Required<JoinOptions>) {\n\tconst logger = document.getLogger();\n\tconst groups = {} as Record<string, IJoinGroup>;\n\n\t// Scan for compatible Primitives.\n\tconst children = parent.listChildren();\n\tfor (let nodeIndex = 0; nodeIndex < children.length; nodeIndex++) {\n\t\tconst node = children[nodeIndex];\n\n\t\t// Skip animated nodes.\n\t\tconst isAnimated = node.listParents().some((p) => p instanceof AnimationChannel);\n\t\tif (isAnimated) continue;\n\n\t\t// Skip nodes without meshes.\n\t\tconst mesh = node.getMesh();\n\t\tif (!mesh) continue;\n\n\t\t// Skip nodes with instancing; unsupported.\n\t\tif (node.getExtension('EXT_mesh_gpu_instancing')) continue;\n\n\t\t// Skip nodes with skinning; unsupported.\n\t\tif (node.getSkin()) continue;\n\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t// Skip prims with morph targets; unsupported.\n\t\t\tif (prim.listTargets().length > 0) continue;\n\n\t\t\t// Skip prims with volumetric materials; unsupported.\n\t\t\tconst material = prim.getMaterial();\n\t\t\tif (material && material.getExtension('KHR_materials_volume')) continue;\n\n\t\t\tdequantizeTransformableAttributes(prim);\n\n\t\t\tlet key = createPrimGroupKey(prim);\n\n\t\t\tconst isNamed = mesh.getName() || node.getName();\n\t\t\tif (options.keepMeshes || (options.keepNamed && isNamed)) {\n\t\t\t\tkey += `|${nodeIndex}`;\n\t\t\t}\n\n\t\t\tif (!(key in groups)) {\n\t\t\t\tgroups[key] = {\n\t\t\t\t\tprims: [] as Primitive[],\n\t\t\t\t\tprimMeshes: [] as Mesh[],\n\t\t\t\t\tprimNodes: [] as Node[],\n\t\t\t\t\tdstNode: node,\n\t\t\t\t\tdstMesh: undefined,\n\t\t\t\t} as IJoinGroup;\n\t\t\t}\n\n\t\t\tconst group = groups[key];\n\t\t\tgroup.prims.push(prim);\n\t\t\tgroup.primNodes.push(node);\n\t\t}\n\t}\n\n\t// Discard single-Primitive groups.\n\tconst joinGroups = Object.values(groups).filter(({ prims }) => prims.length > 1);\n\n\t// Unlink all affected Meshes at current level, before modifying Primitives.\n\tconst srcNodes = new Set<Node>(joinGroups.flatMap((group) => group.primNodes));\n\tfor (const node of srcNodes) {\n\t\tconst mesh = node.getMesh()!;\n\t\tconst isSharedMesh = mesh.listParents().some((parent) => {\n\t\t\treturn parent.propertyType !== ROOT && node !== parent;\n\t\t});\n\t\tif (isSharedMesh) {\n\t\t\tnode.setMesh(mesh.clone());\n\t\t}\n\t}\n\n\t// Update Meshes in groups.\n\tfor (const group of joinGroups) {\n\t\tconst { dstNode, primNodes } = group;\n\t\tgroup.dstMesh = dstNode.getMesh()!;\n\t\tgroup.primMeshes = primNodes.map((node) => node.getMesh()!);\n\t}\n\n\t// Join Primitives.\n\tfor (const group of joinGroups) {\n\t\tconst { prims, primNodes, primMeshes, dstNode, dstMesh } = group as Required<IJoinGroup>;\n\t\tconst dstMatrix = dstNode.getMatrix();\n\n\t\tfor (let i = 0; i < prims.length; i++) {\n\t\t\tconst primNode = primNodes[i];\n\t\t\tconst primMesh = primMeshes[i];\n\n\t\t\tlet prim = prims[i];\n\t\t\tprimMesh.removePrimitive(prim);\n\n\t\t\t// Primitives may be reused directly, or their attributes may be\n\t\t\t// used in another Primitive with a different Material.\n\t\t\tif (isUsed(prim) || hasSharedAttributes(prim)) {\n\t\t\t\tprim = prims[i] = _deepClonePrimitive(prims[i]);\n\t\t\t}\n\n\t\t\t// Transform Primitive into new local coordinate space.\n\t\t\tif (primNode !== dstNode) {\n\t\t\t\tmultiply(_matrix, invert(_matrix, dstMatrix), primNode.getMatrix());\n\t\t\t\ttransformPrimitive(prim, _matrix);\n\t\t\t}\n\t\t}\n\n\t\tconst dstPrim = joinPrimitives(prims);\n\t\tconst dstVertexCount = dstPrim.listAttributes()[0].getCount();\n\t\tdstMesh.addPrimitive(dstPrim);\n\n\t\tlogger.debug(\n\t\t\t`${NAME}: Joined Primitives (${prims.length}) containing ` +\n\t\t\t\t`${formatLong(dstVertexCount)} vertices under Node \"${dstNode.getName()}\".`,\n\t\t);\n\t}\n}\n\nfunction _deepClonePrimitive(src: Primitive): Primitive {\n\tconst dst = src.clone();\n\tfor (const semantic of dst.listSemantics()) {\n\t\tdst.setAttribute(semantic, dst.getAttribute(semantic)!.clone());\n\t}\n\tconst indices = dst.getIndices();\n\tif (indices) dst.setIndices(indices.clone());\n\treturn dst;\n}\n\nfunction hasSharedAttributes(prim: Primitive): boolean {\n\tfor (const attribute of prim.listAttributes()) {\n\t\tfor (const parent of attribute.listParents()) {\n\t\t\tif (parent !== prim && parent.propertyType !== ROOT) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Dequantize attributes that would be affected by {@link transformPrimitive},\n * to avoid invalidating our primitive group keys.\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/844\n */\nfunction dequantizeTransformableAttributes(prim: Primitive) {\n\tfor (const semantic of ['POSITION', 'NORMAL', 'TANGENT']) {\n\t\tconst attribute = prim.getAttribute(semantic);\n\t\tif (attribute && attribute.getComponentSize() < 4) {\n\t\t\tdequantizeAttribute(semantic, attribute, { pattern: /.*/ });\n\t\t}\n\t}\n}\n","import { Document, Texture } from '@gltf-transform/core';\nimport { Material, TextureChannel, PropertyType } from '@gltf-transform/core';\n\n/**\n * Returns a list of {@link TextureChannel TextureChannels} used by the given\n * texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel\n * in use. See {@link getTextureChannelMask} for bitmask alternative.\n *\n * Example:\n *\n * ```js\n * const channels = listTextureChannels(texture);\n * if (channels.includes(TextureChannel.R)) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function listTextureChannels(texture: Texture): TextureChannel[] {\n\tconst mask = getTextureChannelMask(texture);\n\tconst channels = [];\n\tif (mask & TextureChannel.R) channels.push(TextureChannel.R);\n\tif (mask & TextureChannel.G) channels.push(TextureChannel.G);\n\tif (mask & TextureChannel.B) channels.push(TextureChannel.B);\n\tif (mask & TextureChannel.A) channels.push(TextureChannel.A);\n\treturn channels;\n}\n\n/**\n * Returns bitmask of all {@link TextureChannel TextureChannels} used by the\n * given texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel.\n * See {@link listTextureChannels} for an array alternative.\n *\n * Example:\n *\n * ```js\n * const mask = getTextureChannelMask(texture);\n * if (mask & TextureChannel.R) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function getTextureChannelMask(texture: Texture): number {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tlet mask = 0x0000;\n\tfor (const edge of document.getGraph().listParentEdges(texture)) {\n\t\tconst parent = edge.getParent();\n\t\tlet { channels } = edge.getAttributes() as { channels: number | undefined };\n\n\t\tif (\n\t\t\tchannels &&\n\t\t\tedge.getName() === 'baseColorTexture' &&\n\t\t\tparent instanceof Material &&\n\t\t\tparent.getAlphaMode() === Material.AlphaMode.OPAQUE\n\t\t) {\n\t\t\tchannels &= ~TextureChannel.A;\n\t\t}\n\n\t\tif (channels) {\n\t\t\tmask |= channels;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\tdocument.getLogger().warn(`Missing attribute \".channels\" on edge, \"${edge.getName()}\".`);\n\t\t}\n\t}\n\treturn mask;\n}\n","import { Accessor, Document, GLTF, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune.js';\nimport { createTransform, deepListAttributes, remapAttribute, SetMap } from './utils.js';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst NAME = 'reorder';\n\n/** Options for the {@link reorder} function. */\nexport interface ReorderOptions {\n\t/** MeshoptEncoder instance. */\n\tencoder: unknown;\n\t/**\n\t * Whether the order should be optimal for transmission size (recommended for Web)\n\t * or for GPU rendering performance. Default is 'size'.\n\t */\n\ttarget?: 'size' | 'performance';\n}\n\nconst REORDER_DEFAULTS: Required<Omit<ReorderOptions, 'encoder'>> = {\n\ttarget: 'size',\n};\n\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function reorder(_options: ReorderOptions): Transform {\n\tconst options = { ...REORDER_DEFAULTS, ..._options } as Required<ReorderOptions>;\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tawait encoder.ready;\n\n\t\tconst plan = createLayoutPlan(doc);\n\n\t\tfor (const srcIndices of plan.indicesToAttributes.keys()) {\n\t\t\tconst dstIndices = srcIndices.clone();\n\t\t\tlet indicesArray = dstIndices.getArray()!.slice();\n\t\t\tif (!(indicesArray instanceof Uint32Array)) {\n\t\t\t\tindicesArray = new Uint32Array(indicesArray);\n\t\t\t}\n\n\t\t\t// Compute optimal order.\n\t\t\tconst [remap, unique] = encoder.reorderMesh(\n\t\t\t\tindicesArray,\n\t\t\t\tplan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES,\n\t\t\t\toptions.target === 'size',\n\t\t\t);\n\n\t\t\tdstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n\n\t\t\t// Update affected primitives.\n\t\t\tfor (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n\t\t\t\tconst dstAttribute = srcAttribute.clone();\n\t\t\t\tremapAttribute(dstAttribute, remap, unique);\n\t\t\t\tfor (const prim of plan.attributesToPrimitives.get(srcAttribute)) {\n\t\t\t\t\tif (prim.getIndices() === srcIndices) {\n\t\t\t\t\t\tprim.swap(srcIndices, dstIndices);\n\t\t\t\t\t}\n\t\t\t\t\tif (prim.getIndices() === dstIndices) {\n\t\t\t\t\t\tprim.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any attributes left unused by earlier cloning.\n\t\tawait doc.transform(\n\t\t\tprune({\n\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR],\n\t\t\t\tkeepAttributes: true,\n\t\t\t\tkeepIndices: true,\n\t\t\t}),\n\t\t);\n\n\t\tif (!plan.indicesToAttributes.size) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found; may need to weld first.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n/** @hidden */\ninterface LayoutPlan {\n\tindicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;\n\tindicesToAttributes: SetMap<Accessor, Accessor>;\n\tattributesToPrimitives: SetMap<Accessor, Primitive>;\n}\n\n/**\n * Constructs a plan for processing vertex streams, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n *\n * @hidden\n */\nfunction createLayoutPlan(document: Document): LayoutPlan {\n\tconst indicesToAttributes = new SetMap<Accessor, Accessor>();\n\tconst indicesToMode = new Map<Accessor, GLTF.MeshPrimitiveMode>();\n\tconst attributesToPrimitives = new SetMap<Accessor, Primitive>();\n\n\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (!indices) continue;\n\n\t\t\tindicesToMode.set(indices, prim.getMode());\n\n\t\t\tfor (const attribute of deepListAttributes(prim)) {\n\t\t\t\tindicesToAttributes.add(indices, attribute);\n\t\t\t\tattributesToPrimitives.add(attribute, prim);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { indicesToAttributes, indicesToMode, attributesToPrimitives };\n}\n","import { Accessor, GLTF, MathUtils, Primitive, PrimitiveTarget, TypedArray, vec4 } from '@gltf-transform/core';\n\n/**\n * Sorts skinning weights from high to low, for each vertex of the input\n * {@link Primitive} or {@link PrimitiveTarget}, and normalizes the weights.\n * Optionally, uses the given 'limit' to remove least-significant joint\n * influences such that no vertex has more than 'limit' influences.\n *\n * Most realtime engines support a limited number of joint influences per vertex,\n * often 4 or 8. Sorting and removing the additional influences can reduce file\n * size and improve compatibility.\n *\n * Example:\n *\n * ```javascript\n * import { sortPrimitiveWeights } from '@gltf-transform/functions';\n *\n * const limit = 4;\n * for (const mesh of document.getRoot().listMeshes()) {\n * \tfor (const prim of mesh.listPrimitives()) {\n * \t\tsortPrimitiveWeights(prim, limit);\n * \t}\n * }\n * ```\n *\n * @param prim Input, to be modified in place.\n * @param limit Maximum number of joint influences per vertex. Must be a multiple of four.\n */\nexport function sortPrimitiveWeights(prim: Primitive | PrimitiveTarget, limit = Infinity) {\n\tif ((Number.isFinite(limit) && limit % 4) || limit <= 0) {\n\t\tthrow new Error(`Limit must be positive multiple of four.`);\n\t}\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\t// (1) Sort.\n\n\tconst indices = new Uint16Array(setCount * 4);\n\tconst srcWeights = new Float32Array(setCount * 4);\n\tconst dstWeights = new Float32Array(setCount * 4);\n\tconst srcJoints = new Uint32Array(setCount * 4);\n\tconst dstJoints = new Uint32Array(setCount * 4);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'WEIGHTS', srcWeights);\n\t\tgetVertexArray(prim, i, 'JOINTS', srcJoints);\n\n\t\t// Sort indices to create a lookup table, indices[dstIndex] → srcIndex,\n\t\t// indexed into the weights and joints arrays.\n\t\tfor (let j = 0; j < setCount * 4; j++) indices[j] = j;\n\t\tindices.sort((a, b) => (srcWeights[a] > srcWeights[b] ? -1 : 1));\n\n\t\t// Sort weights and joints.\n\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\tdstWeights[j] = srcWeights[indices[j]];\n\t\t\tdstJoints[j] = srcJoints[indices[j]];\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'WEIGHTS', dstWeights);\n\t\tsetVertexArray(prim, i, 'JOINTS', dstJoints);\n\t}\n\n\t// (2) Limit.\n\tfor (let i = setCount; i * 4 > limit; i--) {\n\t\tconst weights = prim.getAttribute(`WEIGHTS_${i - 1}`)!;\n\t\tconst joints = prim.getAttribute(`JOINTS_${i - 1}`)!;\n\t\tprim.setAttribute(`WEIGHTS_${i - 1}`, null);\n\t\tprim.setAttribute(`JOINTS_${i - 1}`, null);\n\t\tif (weights.listParents().length === 1) weights.dispose();\n\t\tif (joints.listParents().length === 1) joints.dispose();\n\t}\n\n\t// (3) Normalize.\n\tnormalizePrimitiveWeights(prim);\n}\n\n// Utilities.\n\ntype PrimLike = Primitive | PrimitiveTarget;\n\nfunction normalizePrimitiveWeights(prim: PrimLike): void {\n\t// Would prefer to warn if unsafe, but no logger accessible in this scope.\n\tif (!isNormalizeSafe(prim)) return;\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\tconst templateAttribute = prim.getAttribute('WEIGHTS_0')!;\n\tconst templateArray = templateAttribute.getArray()!;\n\tconst componentType = templateAttribute.getComponentType();\n\tconst normalized = templateAttribute.getNormalized();\n\tconst normalizedComponentType = normalized ? componentType : undefined;\n\tconst delta = normalized ? MathUtils.decodeNormalizedInt(1, componentType) : Number.EPSILON;\n\tconst joints = new Uint32Array(setCount * 4).fill(0);\n\tconst weights = templateArray.slice(0, setCount * 4).fill(0);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'JOINTS', joints);\n\t\tgetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\n\t\tlet weightsSum = sum(weights, normalizedComponentType);\n\t\tif (weightsSum === 0) continue;\n\n\t\t// (1) If sum of weights not within δ of 1, renormalize all weights.\n\t\tif (Math.abs(1 - weightsSum) > delta) {\n\t\t\tfor (let j = 0; j < weights.length; j++) {\n\t\t\t\tif (normalized) {\n\t\t\t\t\tconst intValue = MathUtils.encodeNormalizedInt(weights[j] / weightsSum, componentType);\n\t\t\t\t\tweights[j] = MathUtils.decodeNormalizedInt(intValue, componentType);\n\t\t\t\t} else {\n\t\t\t\t\tweights[j] /= weightsSum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tweightsSum = sum(weights, normalizedComponentType);\n\n\t\t// (2) Sum of normalized weights may still be off by δ. Compensate\n\t\t// in least-significant weight.\n\t\tif (normalized && weightsSum !== 1) {\n\t\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\t\tif (weights[j] > 0) {\n\t\t\t\t\tweights[j] += MathUtils.encodeNormalizedInt(1 - weightsSum, componentType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Remove joint indices whose weights have fallen to zero.\n\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\tif (weights[j] === 0) {\n\t\t\t\tjoints[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'JOINTS', joints);\n\t\tsetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\t}\n}\n\n/** Lists all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction getVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\ttarget: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType\n): TypedArray {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tweights.getElement(vertexIndex, el);\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\ttarget[i * 4 + j] = MathUtils.encodeNormalizedInt(el[j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\ttarget[i * 4 + j] = el[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n/** Sets all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction setVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\tvalues: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType\n): void {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\tel[j] = MathUtils.decodeNormalizedInt(values[i * 4 + j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\tel[j] = values[i * 4 + j];\n\t\t\t}\n\t\t}\n\t\tweights.setElement(vertexIndex, el);\n\t}\n}\n\n/** Sum an array of numbers. */\nfunction sum(values: TypedArray, normalizedComponentType?: GLTF.AccessorComponentType): number {\n\tlet sum = 0;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tif (normalizedComponentType) {\n\t\t\tsum += MathUtils.decodeNormalizedInt(values[i], normalizedComponentType);\n\t\t} else {\n\t\t\tsum += values[i];\n\t\t}\n\t}\n\treturn sum;\n}\n\n/** Returns true if attribute normalization is supported for this primitive. */\nfunction isNormalizeSafe(prim: PrimLike): boolean {\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.filter((name) => name.startsWith('WEIGHTS_'))\n\t\t.map((name) => prim.getAttribute(name)!);\n\tconst normList = attributes.map((a) => a.getNormalized());\n\tconst typeList = attributes.map((a) => a.getComponentType());\n\treturn new Set(normList).size === 1 && new Set(typeList).size === 1;\n}\n","import {\n\tAccessor,\n\tAnimationChannel,\n\tbbox,\n\tDocument,\n\tILogger,\n\tmat4,\n\tMathUtils,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tSkin,\n\tTransform,\n\tvec2,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup.js';\nimport { fromRotationTranslationScale, fromScaling, invert, multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { max, min, scale, transformMat4 } from 'gl-matrix/vec3';\nimport { InstancedMesh, KHRMeshQuantization } from '@gltf-transform/extensions';\nimport type { Volume } from '@gltf-transform/extensions';\nimport { prune } from './prune.js';\nimport { createTransform } from './utils.js';\nimport { sortPrimitiveWeights } from './sort-primitive-weights.js';\n\nconst NAME = 'quantize';\n\ntype TypedArrayConstructor =\n\t| Int8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Uint16ArrayConstructor;\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array] as TypedArrayConstructor[];\n\nconst { TRANSLATION, ROTATION, SCALE, WEIGHTS } = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\n\n/** Options for the {@link quantize} function. */\nexport interface QuantizeOptions {\n\t/** Pattern (regex) used to filter vertex attribute semantics for quantization. Default: all. */\n\tpattern?: RegExp;\n\t/** Pattern (regex) used to filter morph target semantics for quantization. Default: `options.pattern`. */\n\tpatternTargets?: RegExp;\n\t/** Bounds for quantization grid. */\n\tquantizationVolume?: 'mesh' | 'scene';\n\t/** Quantization bits for `POSITION` attributes. */\n\tquantizePosition?: number;\n\t/** Quantization bits for `NORMAL` attributes. */\n\tquantizeNormal?: number;\n\t/** Quantization bits for `TEXCOORD_*` attributes. */\n\tquantizeTexcoord?: number;\n\t/** Quantization bits for `COLOR_*` attributes. */\n\tquantizeColor?: number;\n\t/** Quantization bits for `WEIGHT_*` attributes. */\n\tquantizeWeight?: number;\n\t/** Quantization bits for application-specific (`_*`) attributes. */\n\tquantizeGeneric?: number;\n\t/** Normalize weight attributes. */\n\tnormalizeWeights?: boolean;\n}\n\nexport const QUANTIZE_DEFAULTS: Required<Omit<QuantizeOptions, 'patternTargets'>> = {\n\tpattern: /.*/,\n\tquantizationVolume: 'mesh',\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeTexcoord: 12,\n\tquantizeColor: 8,\n\tquantizeWeight: 8,\n\tquantizeGeneric: 12,\n\tnormalizeWeights: true,\n};\n\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file.\n *\n * @category Transforms\n */\nexport function quantize(_options: QuantizeOptions = QUANTIZE_DEFAULTS): Transform {\n\tconst options = { ...QUANTIZE_DEFAULTS, ..._options } as Required<QuantizeOptions>;\n\n\toptions.patternTargets = options.patternTargets || options.pattern;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tdoc.createExtension(KHRMeshQuantization).setRequired(true);\n\n\t\t// Compute vertex position quantization volume.\n\t\tlet nodeTransform: VectorTransform<vec3> | undefined = undefined;\n\t\tif (options.quantizationVolume === 'scene') {\n\t\t\tnodeTransform = getNodeTransform(expandBounds(root.listMeshes().map(getPositionQuantizationVolume)));\n\t\t}\n\n\t\t// Quantize mesh primitives.\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tif (options.quantizationVolume === 'mesh') {\n\t\t\t\tnodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n\t\t\t}\n\n\t\t\tif (nodeTransform && options.pattern.test('POSITION')) {\n\t\t\t\ttransformMeshParents(doc, mesh, nodeTransform);\n\t\t\t\ttransformMeshMaterials(mesh, 1 / nodeTransform.scale);\n\t\t\t}\n\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tquantizePrimitive(doc, prim, nodeTransform!, options);\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tquantizePrimitive(doc, target, nodeTransform!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait doc.transform(\n\t\t\tprune({\n\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN, PropertyType.MATERIAL],\n\t\t\t\tkeepAttributes: true,\n\t\t\t\tkeepIndices: true,\n\t\t\t\tkeepLeaves: true,\n\t\t\t\tkeepSolidTextures: true,\n\t\t\t}),\n\t\t\tdedup({\n\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.MATERIAL, PropertyType.SKIN],\n\t\t\t\tkeepUniqueNames: true,\n\t\t\t}),\n\t\t);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction quantizePrimitive(\n\tdoc: Document,\n\tprim: Primitive | PrimitiveTarget,\n\tnodeTransform: VectorTransform<vec3>,\n\toptions: Required<QuantizeOptions>,\n): void {\n\tconst isTarget = prim instanceof PrimitiveTarget;\n\tconst logger = doc.getLogger();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (!isTarget && !options.pattern.test(semantic)) continue;\n\t\tif (isTarget && !options.patternTargets.test(semantic)) continue;\n\n\t\tconst srcAttribute = prim.getAttribute(semantic)!;\n\n\t\tconst { bits, ctor } = getQuantizationSettings(semantic, srcAttribute, logger, options);\n\n\t\tif (!ctor) continue;\n\t\tif (bits < 8 || bits > 16) throw new Error(`${NAME}: Requires bits = 8–16.`);\n\t\tif (srcAttribute.getComponentSize() <= bits / 8) continue;\n\n\t\tconst dstAttribute = srcAttribute.clone();\n\n\t\t// Remap position data.\n\t\tif (semantic === 'POSITION') {\n\t\t\tconst scale = nodeTransform.scale;\n\t\t\tconst transform: mat4 = [] as unknown as mat4;\n\t\t\t// Morph targets are relative offsets, don't translate them.\n\t\t\tprim instanceof Primitive\n\t\t\t\t? invert(transform, fromTransform(nodeTransform))\n\t\t\t\t: fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n\t\t\tfor (let i = 0, el: vec3 = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n\t\t\t\tdstAttribute.getElement(i, el);\n\t\t\t\tdstAttribute.setElement(i, transformMat4(el, el, transform) as vec3);\n\t\t\t}\n\t\t}\n\n\t\t// Quantize the vertex attribute.\n\t\tquantizeAttribute(dstAttribute, ctor, bits);\n\t\tprim.swap(srcAttribute, dstAttribute);\n\t}\n\n\t// Normalize skinning weights.\n\tif (options.normalizeWeights && prim.getAttribute('WEIGHTS_0')) {\n\t\tsortPrimitiveWeights(prim, Infinity);\n\t}\n\n\tif (\n\t\tprim instanceof Primitive &&\n\t\tprim.getIndices() &&\n\t\tprim.listAttributes().length &&\n\t\tprim.listAttributes()[0]!.getCount() < 65535\n\t) {\n\t\tconst indices = prim.getIndices()!;\n\t\tindices.setArray(new Uint16Array(indices.getArray()!));\n\t}\n}\n\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume: bbox): VectorTransform<vec3> {\n\tconst { min, max } = volume;\n\n\t// Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/328\n\tconst scale = Math.max(\n\t\t(max[0] - min[0]) / 2, // Divide because interval [-1,1] has length 2.\n\t\t(max[1] - min[1]) / 2,\n\t\t(max[2] - min[2]) / 2,\n\t);\n\n\t// Original center of the mesh, in local space.\n\tconst offset: vec3 = [\n\t\tmin[0] + (max[0] - min[0]) / 2,\n\t\tmin[1] + (max[1] - min[1]) / 2,\n\t\tmin[2] + (max[2] - min[2]) / 2,\n\t];\n\n\treturn { offset, scale };\n}\n\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(doc: Document, mesh: Mesh, nodeTransform: VectorTransform<vec3>): void {\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tfor (const parent of mesh.listParents()) {\n\t\tif (!(parent instanceof Node)) continue;\n\n\t\tconst animChannels = parent.listParents().filter((p) => p instanceof AnimationChannel) as AnimationChannel[];\n\t\tconst isAnimated = animChannels.some((channel) => TRS_CHANNELS.includes(channel.getTargetPath()!));\n\t\tconst isParentNode = parent.listChildren().length > 0;\n\n\t\tconst skin = parent.getSkin();\n\t\tif (skin) {\n\t\t\tparent.setSkin(transformSkin(skin, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst batch = parent.getExtension<InstancedMesh>('EXT_mesh_gpu_instancing');\n\t\tif (batch) {\n\t\t\tparent.setExtension('EXT_mesh_gpu_instancing', transformBatch(batch, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet targetNode: Node;\n\t\tif (isParentNode || isAnimated) {\n\t\t\ttargetNode = doc.createNode('').setMesh(mesh);\n\t\t\tparent.addChild(targetNode).setMesh(null);\n\t\t\tanimChannels\n\t\t\t\t.filter((channel) => channel.getTargetPath() === WEIGHTS)\n\t\t\t\t.forEach((channel) => channel.setTargetNode(targetNode));\n\t\t} else {\n\t\t\ttargetNode = parent;\n\t\t}\n\n\t\tconst nodeMatrix = targetNode.getMatrix();\n\t\tmultiplyMat4(nodeMatrix, nodeMatrix, transformMatrix);\n\t\ttargetNode.setMatrix(nodeMatrix);\n\t}\n}\n\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin: Skin, nodeTransform: VectorTransform<vec3>): Skin {\n\tskin = skin.clone(); // quantize() does cleanup.\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tconst inverseBindMatrices = skin.getInverseBindMatrices()!.clone();\n\tconst ibm = [] as unknown as mat4;\n\tfor (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n\t\tinverseBindMatrices.getElement(i, ibm);\n\t\tmultiplyMat4(ibm, ibm, transformMatrix);\n\t\tinverseBindMatrices.setElement(i, ibm);\n\t}\n\treturn skin.setInverseBindMatrices(inverseBindMatrices);\n}\n\n/** Applies corrective scale and offset to GPU instancing batches. */\nfunction transformBatch(batch: InstancedMesh, nodeTransform: VectorTransform<vec3>): InstancedMesh {\n\tif (!batch.getAttribute('TRANSLATION') && !batch.getAttribute('ROTATION') && !batch.getAttribute('SCALE')) {\n\t\treturn batch;\n\t}\n\n\tbatch = batch.clone(); // quantize() does cleanup.\n\tconst instanceTranslation = batch.getAttribute('TRANSLATION')?.clone();\n\tconst instanceRotation = batch.getAttribute('ROTATION')?.clone();\n\tconst instanceScale = batch.getAttribute('SCALE')?.clone();\n\tconst tpl = (instanceTranslation || instanceRotation || instanceScale)!;\n\n\tconst T_IDENTITY = [0, 0, 0] as vec3;\n\tconst R_IDENTITY = [0, 0, 0, 1] as vec4;\n\tconst S_IDENTITY = [1, 1, 1] as vec3;\n\n\tconst t = [0, 0, 0] as vec3;\n\tconst r = [0, 0, 0, 1] as vec4;\n\tconst s = [1, 1, 1] as vec3;\n\n\t// prettier-ignore\n\tconst instanceMatrix = [\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1,\n\t] as mat4;\n\n\tconst transformMatrix = fromTransform(nodeTransform);\n\n\tfor (let i = 0, count = tpl.getCount(); i < count; i++) {\n\t\tMathUtils.compose(\n\t\t\tinstanceTranslation ? (instanceTranslation.getElement(i, t) as vec3) : T_IDENTITY,\n\t\t\tinstanceRotation ? (instanceRotation.getElement(i, r) as vec4) : R_IDENTITY,\n\t\t\tinstanceScale ? (instanceScale.getElement(i, s) as vec3) : S_IDENTITY,\n\t\t\tinstanceMatrix,\n\t\t);\n\n\t\tmultiplyMat4(instanceMatrix, instanceMatrix, transformMatrix);\n\n\t\tMathUtils.decompose(instanceMatrix, t, r, s);\n\n\t\tif (instanceTranslation) instanceTranslation.setElement(i, t);\n\t\tif (instanceRotation) instanceRotation.setElement(i, r);\n\t\tif (instanceScale) instanceScale.setElement(i, s);\n\t}\n\n\tif (instanceTranslation) batch.setAttribute('TRANSLATION', instanceTranslation);\n\tif (instanceRotation) batch.setAttribute('ROTATION', instanceRotation);\n\tif (instanceScale) batch.setAttribute('SCALE', instanceScale);\n\n\treturn batch;\n}\n\n/** Applies corrective scale to volumetric materials, which give thickness in local units. */\nfunction transformMeshMaterials(mesh: Mesh, scale: number) {\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tlet material = prim.getMaterial();\n\t\tif (!material) continue;\n\n\t\tlet volume = material.getExtension<Volume>('KHR_materials_volume');\n\t\tif (!volume || volume.getThicknessFactor() <= 0) continue;\n\n\t\t// quantize() does cleanup.\n\t\tvolume = volume.clone().setThicknessFactor(volume.getThicknessFactor() * scale);\n\t\tmaterial = material.clone().setExtension('KHR_materials_volume', volume);\n\t\tprim.setMaterial(material);\n\t}\n}\n\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(attribute: Accessor, ctor: TypedArrayConstructor, bits: number): void {\n\tconst dstArray = new ctor(attribute.getArray()!.length);\n\n\tconst signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n\tconst quantBits = bits - signBits;\n\tconst storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n\n\tconst scale = Math.pow(2, quantBits) - 1;\n\tconst lo = storageBits - quantBits;\n\tconst hi = 2 * quantBits - storageBits;\n\tconst range = [signBits > 0 ? -1 : 0, 1] as vec2;\n\n\tfor (let i = 0, di = 0, el: number[] = []; i < attribute.getCount(); i++) {\n\t\tattribute.getElement(i, el);\n\t\tfor (let j = 0; j < el.length; j++) {\n\t\t\t// Clamp to range.\n\t\t\tlet value = clamp(el[j], range);\n\n\t\t\t// Map [0.0 ... 1.0] to [0 ... scale].\n\t\t\tvalue = Math.round(Math.abs(value) * scale);\n\n\t\t\t// Replicate msb to missing lsb.\n\t\t\tvalue = (value << lo) | (value >> hi);\n\n\t\t\t// Restore sign.\n\t\t\tdstArray[di++] = value * Math.sign(el[j]);\n\t\t}\n\t}\n\n\t// TODO(feat): Support sparse accessors, https://github.com/donmccurdy/glTF-Transform/issues/795\n\tattribute.setArray(dstArray).setNormalized(true).setSparse(false);\n}\n\nfunction getQuantizationSettings(\n\tsemantic: string,\n\tattribute: Accessor,\n\tlogger: ILogger,\n\toptions: Required<QuantizeOptions>,\n): { bits: number; ctor?: TypedArrayConstructor } {\n\tconst min = attribute.getMinNormalized([]);\n\tconst max = attribute.getMaxNormalized([]);\n\n\tlet bits: number;\n\tlet ctor: TypedArrayConstructor;\n\n\tif (semantic === 'POSITION') {\n\t\tbits = options.quantizePosition;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n\t\tbits = options.quantizeNormal;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\tbits = options.quantizeColor;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeTexcoord;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('JOINTS_')) {\n\t\tbits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t\tif (attribute.getComponentSize() > bits / 8) {\n\t\t\tattribute.setArray(new ctor(attribute.getArray()!));\n\t\t}\n\t\treturn { bits: -1 };\n\t} else if (semantic.startsWith('WEIGHTS_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeWeight;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('_')) {\n\t\tif (min.some((v) => v < -1) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [-1,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeGeneric;\n\t\tctor = min.some((v) => v < 0)\n\t\t\t? (ctor = bits <= 8 ? Int8Array : Int16Array)\n\t\t\t: (ctor = bits <= 8 ? Uint8Array : Uint16Array);\n\t} else {\n\t\tthrow new Error(`${NAME}: Unexpected semantic, \"${semantic}\".`);\n\t}\n\n\treturn { bits, ctor };\n}\n\nfunction getPositionQuantizationVolume(mesh: Mesh): bbox {\n\tconst positions: Accessor[] = [];\n\tconst relativePositions: Accessor[] = [];\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst attribute = prim.getAttribute('POSITION');\n\t\tif (attribute) positions.push(attribute);\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tconst attribute = target.getAttribute('POSITION');\n\t\t\tif (attribute) relativePositions.push(attribute);\n\t\t}\n\t}\n\n\tif (positions.length === 0) {\n\t\tthrow new Error(`${NAME}: Missing \"POSITION\" attribute.`);\n\t}\n\n\tconst bbox = flatBounds<vec3>(positions, 3);\n\n\t// Morph target quantization volume is computed differently. First, ensure that the origin\n\t// <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n\t// relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n\t// to ensure scaling puts them within a [-1, 1] AABB instead.\n\tif (relativePositions.length > 0) {\n\t\tconst { min: relMin, max: relMax } = flatBounds<vec3>(relativePositions, 3);\n\t\tmin(bbox.min, bbox.min, min(relMin, scale(relMin, relMin, 2), [0, 0, 0]));\n\t\tmax(bbox.max, bbox.max, max(relMax, scale(relMax, relMax, 2), [0, 0, 0]));\n\t}\n\n\treturn bbox;\n}\n\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds<T = vec2 | vec3>(accessors: Accessor[], elementSize: number): { min: T; max: T } {\n\tconst min: number[] = new Array(elementSize).fill(Infinity);\n\tconst max: number[] = new Array(elementSize).fill(-Infinity);\n\n\tconst tmpMin: number[] = [];\n\tconst tmpMax: number[] = [];\n\n\tfor (const accessor of accessors) {\n\t\taccessor.getMinNormalized(tmpMin);\n\t\taccessor.getMaxNormalized(tmpMax);\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tmin[i] = Math.min(min[i], tmpMin[i]);\n\t\t\tmax[i] = Math.max(max[i], tmpMax[i]);\n\t\t}\n\t}\n\n\treturn { min, max } as unknown as { min: T; max: T };\n}\n\nfunction expandBounds(bboxes: bbox[]): bbox {\n\tconst result = bboxes[0];\n\tfor (const bbox of bboxes) {\n\t\tmin(result.min, result.min, bbox.min);\n\t\tmax(result.max, result.max, bbox.max);\n\t}\n\treturn result;\n}\n\ninterface VectorTransform<T = vec2 | vec3 | vec4> {\n\toffset: T;\n\tscale: number;\n}\n\nfunction fromTransform(transform: VectorTransform<vec3>): mat4 {\n\treturn fromRotationTranslationScale([] as unknown as mat4, [0, 0, 0, 1], transform.offset, [\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t]) as mat4;\n}\n\nfunction clamp(value: number, range: vec2): number {\n\treturn Math.min(Math.max(value, range[0]), range[1]);\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { EXTMeshoptCompression } from '@gltf-transform/extensions';\nimport type { MeshoptEncoder } from 'meshoptimizer';\nimport { reorder } from './reorder.js';\nimport { QUANTIZE_DEFAULTS, QuantizeOptions, quantize } from './quantize.js';\nimport { createTransform } from './utils.js';\n\nexport interface MeshoptOptions extends Omit<QuantizeOptions, 'pattern' | 'patternTargets'> {\n\tencoder: unknown;\n\tlevel?: 'medium' | 'high';\n}\n\nexport const MESHOPT_DEFAULTS: Required<Omit<MeshoptOptions, 'encoder'>> = {\n\tlevel: 'high',\n\t...QUANTIZE_DEFAULTS,\n};\n\nconst NAME = 'meshopt';\n\n/**\n * Applies Meshopt compression using {@link EXTMeshoptCompression EXT_meshopt_compression}.\n * This type of compression can reduce the size of point, line, and triangle geometry,\n * morph targets, and animation data.\n *\n * This function is a thin wrapper around {@link reorder}, {@link quantize}, and\n * {@link EXTMeshoptCompression}, and exposes relatively few configuration options.\n * To access more options (like quantization bits) direct use of the underlying\n * functions is recommended.\n *\n * Example:\n *\n * ```javascript\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n *   reorder({encoder: MeshoptEncoder, level: 'medium'})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function meshopt(_options: MeshoptOptions): Transform {\n\tconst options = { ...MESHOPT_DEFAULTS, ..._options } as Required<MeshoptOptions>;\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tlet pattern: RegExp;\n\t\tlet patternTargets: RegExp;\n\t\tlet quantizeNormal = options.quantizeNormal;\n\n\t\t// IMPORTANT: Vertex attributes should be quantized in 'high' mode IFF they are\n\t\t// _not_ filtered in 'packages/extensions/src/ext-meshopt-compression/encoder.ts'.\n\t\t// Note that normals and tangents use octahedral filters, but _morph_ normals\n\t\t// and tangents do not.\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/1142\n\t\tif (options.level === 'medium') {\n\t\t\tpattern = /.*/;\n\t\t\tpatternTargets = /.*/;\n\t\t} else {\n\t\t\tpattern = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/;\n\t\t\tpatternTargets = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS|NORMAL|TANGENT)(_\\d+)?$/;\n\t\t\tquantizeNormal = Math.min(quantizeNormal, 8); // See meshopt::getMeshoptFilter.\n\t\t}\n\n\t\tawait document.transform(\n\t\t\treorder({\n\t\t\t\tencoder: encoder,\n\t\t\t\ttarget: 'size',\n\t\t\t}),\n\t\t\tquantize({\n\t\t\t\t...options,\n\t\t\t\tpattern,\n\t\t\t\tpatternTargets,\n\t\t\t\tquantizeNormal,\n\t\t\t}),\n\t\t);\n\n\t\tdocument\n\t\t\t.createExtension(EXTMeshoptCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.level === 'medium'\n\t\t\t\t\t\t? EXTMeshoptCompression.EncoderMethod.QUANTIZE\n\t\t\t\t\t\t: EXTMeshoptCompression.EncoderMethod.FILTER,\n\t\t\t});\n\t});\n}\n","import type { Document, Texture, Transform } from '@gltf-transform/core';\nimport {\n\tKHRMaterialsIOR,\n\tKHRMaterialsPBRSpecularGlossiness,\n\tKHRMaterialsSpecular,\n\tPBRSpecularGlossiness,\n} from '@gltf-transform/extensions';\nimport { createTransform, rewriteTexture } from './utils.js';\n\nconst NAME = 'metalRough';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MetalRoughOptions {}\n\nconst METALROUGH_DEFAULTS: Required<MetalRoughOptions> = {};\n\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nexport function metalRough(_options: MetalRoughOptions = METALROUGH_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...METALROUGH_DEFAULTS, ..._options } as Required<MetalRoughOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness')) {\n\t\t\tlogger.warn(`${NAME}: KHR_materials_pbrSpecularGlossiness not found on document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(KHRMaterialsIOR);\n\t\tconst specExtension = doc.createExtension(KHRMaterialsSpecular);\n\t\tconst specGlossExtension = doc.createExtension(KHRMaterialsPBRSpecularGlossiness);\n\n\t\tconst inputTextures = new Set<Texture | null>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>('KHR_materials_pbrSpecularGlossiness');\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension\n\t\t\t\t.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo()!.copy(specGloss.getDiffuseTextureInfo()!);\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.setSpecularColorTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo()!.copy(sgTextureInfo);\n\t\t\t\tspecular.getSpecularColorTextureInfo()!.copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo()!.copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import type { Accessor, Document, ILogger, Transform, TypedArray } from '@gltf-transform/core';\nimport { createTransform, formatDeltaOp } from './utils.js';\n\nconst NAME = 'unweld';\n\n/** Options for the {@link unweld} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnweldOptions {}\n\nconst UNWELD_DEFAULTS: UnweldOptions = {};\n\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nexport function unweld(_options: UnweldOptions = UNWELD_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...UNWELD_DEFAULTS, ..._options } as Required<UnweldOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst visited = new Map<Accessor, Map<Accessor, Accessor>>();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (!indices) continue;\n\n\t\t\t\tconst srcVertexCount = prim.getAttribute('POSITION')!.getCount();\n\n\t\t\t\t// Vertex attributes.\n\t\t\t\tfor (const srcAttribute of prim.listAttributes()) {\n\t\t\t\t\tprim.swap(srcAttribute, unweldAttribute(srcAttribute, indices, logger, visited));\n\n\t\t\t\t\t// Clean up.\n\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t}\n\n\t\t\t\t// Morph target vertex attributes.\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\t\t\t\ttarget.swap(srcAttribute, unweldAttribute(srcAttribute, indices, logger, visited));\n\n\t\t\t\t\t\t// Clean up.\n\t\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dstVertexCount = prim.getAttribute('POSITION')!.getCount();\n\t\t\t\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t\t\t\t// Clean up.\n\t\t\t\tprim.setIndices(null);\n\t\t\t\tif (indices.listParents().length === 1) indices.dispose();\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction unweldAttribute(\n\tsrcAttribute: Accessor,\n\tindices: Accessor,\n\tlogger: ILogger,\n\tvisited: Map<Accessor, Map<Accessor, Accessor>>\n): Accessor {\n\tif (visited.has(srcAttribute) && visited.get(srcAttribute)!.has(indices)) {\n\t\tlogger.debug(`${NAME}: Cache hit for reused attribute, \"${srcAttribute.getName()}\".`);\n\t\treturn visited.get(srcAttribute)!.get(indices)!;\n\t}\n\n\tconst dstAttribute = srcAttribute.clone();\n\tconst ArrayCtor = srcAttribute.getArray()!.constructor as new (len: number) => TypedArray;\n\tdstAttribute.setArray(new ArrayCtor(indices.getCount() * srcAttribute.getElementSize()));\n\n\tconst el: number[] = [];\n\tfor (let i = 0; i < indices.getCount(); i++) {\n\t\tdstAttribute.setElement(i, srcAttribute.getElement(indices.getScalar(i), el));\n\t}\n\n\tif (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n\tvisited.get(srcAttribute)!.set(indices, dstAttribute);\n\n\treturn dstAttribute;\n}\n","import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { unweld } from './unweld.js';\nimport { createTransform } from './utils.js';\nimport { normalize } from 'gl-matrix/vec3';\n\nconst NAME = 'normals';\n\n/** Options for the {@link normals} function. */\nexport interface NormalsOptions {\n\t/** Whether to overwrite existing `NORMAL` attributes. */\n\toverwrite?: boolean;\n}\n\nconst NORMALS_DEFAULTS: Required<NormalsOptions> = {\n\toverwrite: false,\n};\n\n/**\n * Generates flat vertex normals for mesh primitives.\n *\n * Example:\n *\n * ```ts\n * import { normals } from '@gltf-transform/functions';\n *\n * await document.transform(normals({overwrite: true}));\n * ```\n *\n * @category Transforms\n */\nexport function normals(_options: NormalsOptions = NORMALS_DEFAULTS): Transform {\n\tconst options = { ...NORMALS_DEFAULTS, ..._options } as Required<NormalsOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tlet modified = 0;\n\n\t\tawait document.transform(unweld());\n\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\t\tlet normal = prim.getAttribute('NORMAL');\n\n\t\t\t\tif (options.overwrite && normal) {\n\t\t\t\t\tnormal.dispose();\n\t\t\t\t} else if (normal) {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping primitive: NORMAL found.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnormal = document\n\t\t\t\t\t.createAccessor()\n\t\t\t\t\t.setArray(new Float32Array(position.getCount() * 3))\n\t\t\t\t\t.setType('VEC3');\n\n\t\t\t\tconst a = [0, 0, 0] as vec3;\n\t\t\t\tconst b = [0, 0, 0] as vec3;\n\t\t\t\tconst c = [0, 0, 0] as vec3;\n\n\t\t\t\tfor (let i = 0; i < position.getCount(); i += 3) {\n\t\t\t\t\tposition.getElement(i + 0, a);\n\t\t\t\t\tposition.getElement(i + 1, b);\n\t\t\t\t\tposition.getElement(i + 2, c);\n\n\t\t\t\t\tconst faceNormal = computeNormal(a, b, c);\n\n\t\t\t\t\tnormal.setElement(i + 0, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 1, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 2, faceNormal);\n\t\t\t\t}\n\n\t\t\t\tprim.setAttribute('NORMAL', normal);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n// https://stackoverflow.com/a/23709352/1314762\nfunction computeNormal(a: vec3, b: vec3, c: vec3): vec3 {\n\tconst A = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];\n\tconst B = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];\n\tconst n = [\n\t\tA[1] * B[2] - A[2] * B[1], //\n\t\tA[2] * B[0] - A[0] * B[2],\n\t\tA[0] * B[1] - A[1] * B[0],\n\t] as vec3;\n\treturn normalize([0, 0, 0], n) as vec3;\n}\n","import {\n\tColorUtils,\n\tDocument,\n\tMaterial,\n\tPrimitive,\n\tPropertyType,\n\tTexture,\n\tTextureInfo,\n\tTransform,\n\tvec4,\n} from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\nimport { prune } from './prune.js';\nimport ndarray, { NdArray, TypedArray } from 'ndarray';\nimport { savePixels } from 'ndarray-pixels';\n\nconst NAME = 'palette';\n\ntype TexturableProp = 'baseColor' | 'emissive' | 'metallicRoughness';\n\nexport interface PaletteOptions {\n\t/** Size (in pixels) of a single block within each palette texture. Default: 4. */\n\tblockSize?: number;\n\t/**\n\t * Minimum number of blocks in the palette texture. If fewer unique\n\t * material values are found, no palettes will be generated. Default: 2.\n\t */\n\tmin?: number;\n}\n\nexport const PALETTE_DEFAULTS: Required<PaletteOptions> = {\n\tblockSize: 4,\n\tmin: 2,\n};\n\n/**\n * Creates palette textures containing all unique values of scalar\n * {@link Material} properties within the scene, then merges materials. For\n * scenes with many solid-colored materials (often found in CAD, architectural,\n * or low-poly styles), texture palettes can reduce the number of materials\n * used, and significantly increase the number of {@link Mesh} objects eligible\n * for {@link join} operations.\n *\n * Materials already containing texture coordinates (UVs) are not eligible for\n * texture palette optimizations. Currently only a material's base color,\n * alpha, emissive factor, metallic factor, and roughness factor are converted\n * to palette textures.\n *\n * Example:\n *\n * ```typescript\n * import { palette, flatten, dequantize, join } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tpalette({ min: 5 }),\n * \tflatten(),\n * \tdequantize(),\n * \tjoin()\n * );\n * ```\n *\n * The illustration below shows a typical base color palette texture:\n *\n * <img\n * \tsrc=\"/media/functions/palette.png\"\n * \talt=\"Row of colored blocks\"\n * \tstyle=\"width: 100%; max-width: 320px; image-rendering: pixelated;\">\n *\n * @category Transforms\n */\nexport function palette(_options: PaletteOptions = PALETTE_DEFAULTS): Transform {\n\tconst options = { ...PALETTE_DEFAULTS, ..._options } as Required<PaletteOptions>;\n\tconst blockSize = Math.max(options.blockSize, 1);\n\tconst min = Math.max(options.min, 1);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\n\t\t// Find and remove unused TEXCOORD_n attributes.\n\t\tawait document.transform(\n\t\t\tprune({\n\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR],\n\t\t\t\tkeepAttributes: false,\n\t\t\t\tkeepIndices: true,\n\t\t\t\tkeepLeaves: true,\n\t\t\t}),\n\t\t);\n\n\t\tconst prims = new Set<Primitive>();\n\t\tconst materials = new Set<Material>();\n\n\t\t// (1) Gather list of eligible prims and materials.\n\n\t\tfor (const mesh of root.listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst material = prim.getMaterial();\n\t\t\t\tif (!material || !!prim.getAttribute('TEXCOORD_0')) continue;\n\n\t\t\t\tprims.add(prim);\n\t\t\t\tmaterials.add(material);\n\t\t\t}\n\t\t}\n\n\t\t// (2) Gather list of distinct material properties.\n\n\t\tconst materialKeys = new Set<string>();\n\t\tconst materialKeyMap = new Map<Material, string>();\n\t\tconst materialProps: Record<TexturableProp, Set<string>> = {\n\t\t\tbaseColor: new Set<string>(),\n\t\t\temissive: new Set<string>(),\n\t\t\tmetallicRoughness: new Set<string>(),\n\t\t};\n\n\t\tfor (const material of materials) {\n\t\t\tconst baseColor = encodeRGBA(material.getBaseColorFactor().slice() as vec4);\n\t\t\tconst emissive = encodeRGBA([...material.getEmissiveFactor(), 1]);\n\t\t\tconst roughness = encodeFloat(material.getRoughnessFactor());\n\t\t\tconst metallic = encodeFloat(material.getMetallicFactor());\n\t\t\tconst key = `baseColor:${baseColor},emissive:${emissive},metallicRoughness:${metallic}${roughness}`;\n\t\t\tmaterialProps.baseColor.add(baseColor);\n\t\t\tmaterialProps.emissive.add(emissive);\n\t\t\tmaterialProps.metallicRoughness.add(metallic + '+' + roughness);\n\t\t\tmaterialKeys.add(key);\n\t\t\tmaterialKeyMap.set(material, key);\n\t\t}\n\n\t\t// logger.debug(`${NAME}:\\n${Array.from(materialKeys.values()).join('\\n')}`);\n\n\t\tconst keyCount = materialKeys.size;\n\t\tif (keyCount < min) {\n\t\t\tlogger.debug(`${NAME}: Found <${min} unique material properties. Exiting.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// (3) Allocate palette textures.\n\n\t\tconst w = ceilPowerOfTwo(keyCount * blockSize);\n\t\tconst h = ceilPowerOfTwo(blockSize);\n\t\tconst padWidth = w - keyCount * blockSize;\n\n\t\tconst paletteTexturePixels: Record<TexturableProp, NdArray<Uint8Array> | null> = {\n\t\t\tbaseColor: null,\n\t\t\temissive: null,\n\t\t\tmetallicRoughness: null,\n\t\t};\n\n\t\t// Properties skipped for material equality comparisons.\n\t\tconst skipProps = new Set(['name', 'extras']);\n\t\tconst skip = (...props: string[]) => props.forEach((prop) => skipProps.add(prop));\n\n\t\tlet baseColorTexture: Texture | null = null;\n\t\tlet emissiveTexture: Texture | null = null;\n\t\tlet metallicRoughnessTexture: Texture | null = null;\n\n\t\tif (materialProps.baseColor.size >= min) {\n\t\t\tconst name = 'PaletteBaseColor';\n\t\t\tbaseColorTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.baseColor = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('baseColorFactor', 'baseColorTexture', 'baseColorTextureInfo');\n\t\t}\n\t\tif (materialProps.emissive.size >= min) {\n\t\t\tconst name = 'PaletteEmissive';\n\t\t\temissiveTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.emissive = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('emissiveFactor', 'emissiveTexture', 'emissiveTextureInfo');\n\t\t}\n\t\tif (materialProps.metallicRoughness.size >= min) {\n\t\t\tconst name = 'PaletteMetallicRoughness';\n\t\t\tmetallicRoughnessTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.metallicRoughness = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('metallicFactor', 'roughnessFactor', 'metallicRoughnessTexture', 'metallicRoughnessTextureInfo');\n\t\t}\n\n\t\tif (!(baseColorTexture || emissiveTexture || metallicRoughnessTexture)) {\n\t\t\tlogger.debug(`${NAME}: No material property has >=${min} unique values. Exiting.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// (4) Write blocks to palette textures.\n\n\t\tconst visitedKeys = new Set<string>();\n\t\tconst materialIndices = new Map<string, number>();\n\t\tconst paletteMaterials: Material[] = [];\n\n\t\tlet nextIndex = 0;\n\t\tfor (const material of materials) {\n\t\t\tconst key = materialKeyMap.get(material)!;\n\t\t\tif (visitedKeys.has(key)) continue;\n\n\t\t\tconst index = nextIndex++;\n\n\t\t\tif (paletteTexturePixels.baseColor) {\n\t\t\t\tconst pixels = paletteTexturePixels.baseColor;\n\t\t\t\tconst baseColor = [...material.getBaseColorFactor()] as vec4;\n\t\t\t\tColorUtils.convertLinearToSRGB(baseColor, baseColor);\n\t\t\t\twriteBlock(pixels, index, baseColor, blockSize);\n\t\t\t}\n\t\t\tif (paletteTexturePixels.emissive) {\n\t\t\t\tconst pixels = paletteTexturePixels.emissive;\n\t\t\t\tconst emissive = [...material.getEmissiveFactor(), 1] as vec4;\n\t\t\t\tColorUtils.convertLinearToSRGB(emissive, emissive);\n\t\t\t\twriteBlock(pixels, index, emissive, blockSize);\n\t\t\t}\n\t\t\tif (paletteTexturePixels.metallicRoughness) {\n\t\t\t\tconst pixels = paletteTexturePixels.metallicRoughness;\n\t\t\t\tconst metallic = material.getMetallicFactor();\n\t\t\t\tconst roughness = material.getRoughnessFactor();\n\t\t\t\twriteBlock(pixels, index, [0, roughness, metallic, 1], blockSize);\n\t\t\t}\n\n\t\t\tvisitedKeys.add(key);\n\t\t\tmaterialIndices.set(key, index);\n\t\t}\n\n\t\t// (5) Compress palette textures and assign to palette materials.\n\n\t\tconst mimeType = 'image/png';\n\n\t\tif (baseColorTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.baseColor!, mimeType);\n\t\t\tbaseColorTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\t\tif (emissiveTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.emissive!, mimeType);\n\t\t\temissiveTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\t\tif (metallicRoughnessTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.metallicRoughness!, mimeType);\n\t\t\tmetallicRoughnessTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\n\t\t// (6) Create palette materials, generate UVs, and assign both to prims.\n\n\t\tlet nextPaletteMaterialIndex = 1;\n\t\tfor (const prim of prims) {\n\t\t\tconst srcMaterial = prim.getMaterial()!;\n\t\t\tconst key = materialKeyMap.get(srcMaterial)!;\n\t\t\tconst blockIndex = materialIndices.get(key)!;\n\n\t\t\t// UVs are centered horizontally in each block, descending vertically\n\t\t\t// to form a diagonal line in the UV layout. Easy and compressible.\n\t\t\tconst baseUV = (blockIndex + 0.5) / keyCount;\n\t\t\tconst padUV = (baseUV * (w - padWidth)) / w;\n\n\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\tconst buffer = position.getBuffer();\n\t\t\tconst array = new Float32Array(position.getCount() * 2).fill(padUV);\n\t\t\tconst uv = document.createAccessor().setType('VEC2').setArray(array).setBuffer(buffer);\n\n\t\t\tlet dstMaterial;\n\t\t\tfor (const material of paletteMaterials) {\n\t\t\t\tif (material.equals(srcMaterial, skipProps)) {\n\t\t\t\t\tdstMaterial = material;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dstMaterial) {\n\t\t\t\tconst suffix = (nextPaletteMaterialIndex++).toString().padStart(3, '0');\n\t\t\t\tdstMaterial = srcMaterial.clone().setName(`PaletteMaterial${suffix}`);\n\n\t\t\t\tif (baseColorTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setBaseColorFactor([1, 1, 1, 1])\n\t\t\t\t\t\t.setBaseColorTexture(baseColorTexture)\n\t\t\t\t\t\t.getBaseColorTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\t\t\t\tif (emissiveTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setEmissiveFactor([1, 1, 1])\n\t\t\t\t\t\t.setEmissiveTexture(emissiveTexture)\n\t\t\t\t\t\t.getEmissiveTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\t\t\t\tif (metallicRoughnessTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setMetallicFactor(1)\n\t\t\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t\t\t.setMetallicRoughnessTexture(metallicRoughnessTexture)\n\t\t\t\t\t\t.getMetallicRoughnessTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\n\t\t\t\tpaletteMaterials.push(dstMaterial);\n\t\t\t}\n\n\t\t\tprim.setMaterial(dstMaterial).setAttribute('TEXCOORD_0', uv);\n\t\t}\n\n\t\tawait document.transform(prune({ propertyTypes: [PropertyType.MATERIAL] }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** Encodes a floating-point value on the interval [0,1] at 8-bit precision. */\nfunction encodeFloat(value: number): string {\n\tconst hex = Math.round(value * 255).toString(16);\n\treturn hex.length === 1 ? '0' + hex : hex;\n}\n\n/** Encodes an RGBA color in Linear-sRGB-D65 color space. */\nfunction encodeRGBA(value: vec4): string {\n\tColorUtils.convertLinearToSRGB(value, value);\n\treturn value.map(encodeFloat).join('');\n}\n\n/** Returns the nearest higher power of two. */\nfunction ceilPowerOfTwo(value: number): number {\n\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\n/** Writes an NxN block of pixels to an image, at the given block index. */\nfunction writeBlock(pixels: NdArray<TypedArray>, index: number, value: vec4, blockSize: number): void {\n\tfor (let i = 0; i < blockSize; i++) {\n\t\tfor (let j = 0; j < blockSize; j++) {\n\t\t\tpixels.set(index * blockSize + i, j, 0, value[0] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 1, value[1] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 2, value[2] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 3, value[3] * 255);\n\t\t}\n\t}\n}\n","import { Document, ILogger, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune.js';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst PARTITION_DEFAULTS: Required<PartitionOptions> = {\n\tanimations: true,\n\tmeshes: true,\n};\n\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n * ```\n *\n * @category Transforms\n */\nexport function partition(_options: PartitionOptions = PARTITION_DEFAULTS): Transform {\n\tconst options = { ...PARTITION_DEFAULTS, ..._options } as Required<PartitionOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tawait doc.transform(prune({ propertyTypes: [PropertyType.BUFFER] }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction partitionMeshes(doc: Document, logger: ILogger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI())\n\t);\n\n\tdoc.getRoot()\n\t\t.listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) indices.setBuffer(buffer);\n\t\t\t\tprimitive.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\tprimitive.listTargets().forEach((primTarget) => {\n\t\t\t\t\tprimTarget.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations(doc: Document, logger: ILogger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI())\n\t);\n\n\tdoc.getRoot()\n\t\t.listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (input) input.setBuffer(buffer);\n\t\t\t\tif (output) output.setBuffer(buffer);\n\t\t\t});\n\t\t});\n}\n\nfunction createBufferURI(basename: string, existing: Set<string>): string {\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\treturn uri;\n}\n","var InterpolationInternal;\n\n(function (InterpolationInternal) {\n  InterpolationInternal[InterpolationInternal[\"STEP\"] = 0] = \"STEP\";\n  InterpolationInternal[InterpolationInternal[\"LERP\"] = 1] = \"LERP\";\n  InterpolationInternal[InterpolationInternal[\"SLERP\"] = 2] = \"SLERP\";\n})(InterpolationInternal || (InterpolationInternal = {}));\n\nconst TO_INTERPOLATION_INTERNAL = {\n  step: InterpolationInternal.STEP,\n  lerp: InterpolationInternal.LERP,\n  slerp: InterpolationInternal.SLERP\n};\nconst EPSILON = 0.000001;\n\n/* Implementation */\n\nfunction resampleDebug(input, output, interpolation, tolerance = 1e-4) {\n  const elementSize = output.length / input.length;\n  const tmp = new Array(elementSize).fill(0);\n  const value = new Array(elementSize).fill(0);\n  const valueNext = new Array(elementSize).fill(0);\n  const valuePrev = new Array(elementSize).fill(0);\n  const lastIndex = input.length - 1;\n  let writeIndex = 1;\n\n  for (let i = 1; i < lastIndex; ++i) {\n    const timePrev = input[writeIndex - 1];\n    const time = input[i];\n    const timeNext = input[i + 1];\n    const t = (time - timePrev) / (timeNext - timePrev);\n    let keep = false; // Remove unnecessary adjacent keyframes.\n\n    if (time !== timeNext && (i !== 1 || time !== input[0])) {\n      getElement(output, writeIndex - 1, valuePrev);\n      getElement(output, i, value);\n      getElement(output, i + 1, valueNext);\n\n      if (interpolation === 'slerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = slerp(tmp, valuePrev, valueNext, t);\n        const angle = getAngle(valuePrev, value) + getAngle(value, valueNext);\n        keep = !eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;\n      } else if (interpolation === 'lerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = vlerp(tmp, valuePrev, valueNext, t);\n        keep = !eq(value, sample, tolerance);\n      } else if (interpolation === 'step') {\n        // Prune keyframes identical to prev/next keyframes.\n        keep = !eq(value, valuePrev) || !eq(value, valueNext);\n      }\n    } // In-place compaction.\n\n\n    if (keep) {\n      if (i !== writeIndex) {\n        input[writeIndex] = input[i];\n        setElement(output, writeIndex, getElement(output, i, tmp));\n      }\n\n      writeIndex++;\n    }\n  } // Flush last keyframe (compaction looks ahead).\n\n\n  if (lastIndex > 0) {\n    input[writeIndex] = input[lastIndex];\n    setElement(output, writeIndex, getElement(output, lastIndex, tmp));\n    writeIndex++;\n  }\n\n  return writeIndex;\n}\n/* Utilities */\n\nfunction getElement(array, index, target) {\n  for (let i = 0, elementSize = target.length; i < elementSize; i++) {\n    target[i] = array[index * elementSize + i];\n  }\n\n  return target;\n}\n\nfunction setElement(array, index, value) {\n  for (let i = 0, elementSize = value.length; i < elementSize; i++) {\n    array[index * elementSize + i] = value[i];\n  }\n}\n\nfunction eq(a, b, tolerance = 0) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (Math.abs(a[i] - b[i]) > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n\nfunction vlerp(out, a, b, t) {\n  for (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);\n\n  return out;\n} // From gl-matrix.\n\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  let omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\nfunction getAngle(a, b) {\n  const dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/** WASM loader for Web environments. */\nconst wasm = /* #__PURE__ */fetch( /* #__PURE__ */new URL('./release.wasm', import.meta.url));\n\n// SETUP\n///////////////////////////////////////////////////////////////////////////////\n\nlet exports;\nconst ready = /* #__PURE__ */new Promise(async (resolve, reject) => {\n  try {\n    const module = await WebAssembly.compile(await wasm);\n    exports = await instantiate(module, {});\n    resolve();\n  } catch (e) {\n    reject(e);\n  }\n});\n\nasync function instantiate(module, imports = {}) {\n  const instance = await WebAssembly.instantiate(module, {\n    env: Object.assign(Object.create(globalThis), {}, {\n      abort: __abort\n    })\n  });\n  return instance.exports;\n} ///////////////////////////////////////////////////////////////////////////////\n// PUBLIC API\n///////////////////////////////////////////////////////////////////////////////\n\n\nconst CHUNK_SIZE = 1024; // The first and last keyframes cannot be removed in any given step, but we need to\n// somehow remove keyframes on chunk boundaries. So after processing each chunk,\n// we copy its last two keyframes in front of the next chunk, and run from there.\n//\n// 🟩 ⬜️ ⬜️ ⬜️ ⬜️ ⬜️                  // chunk 1, original\n// 🟩 ⬜️ 🟨 🟥                       // chunk 1, resampled\n//            🟨 🟥 🟩 ⬜️ ⬜️ ⬜️       // chunk 2, original\n//            🟨 🟩 ⬜️ ⬜️            // chunk 2, resampled\n// ...\n\nfunction resample(input, output, interpolation, tolerance = 1e-4) {\n  __assert(!!exports, 'Await \"ready\" before using module.');\n\n  __assert(input instanceof Float32Array, 'Missing Float32Array input.');\n\n  __assert(output instanceof Float32Array, 'Missing Float32Array output.');\n\n  const outputSize = output.length / input.length;\n\n  __assert(Number.isInteger(outputSize), 'Invalid input/output counts.');\n\n  __assert(interpolation in TO_INTERPOLATION_INTERNAL, 'Invalid interpolation.');\n\n  __assert(Number.isFinite(tolerance), 'Invalid tolerance');\n\n  const interpVal = TO_INTERPOLATION_INTERNAL[interpolation];\n  const srcCount = input.length;\n  let dstCount = 0;\n\n  for (let chunkStart = 0; chunkStart < input.length; chunkStart += CHUNK_SIZE) {\n    const chunkCount = Math.min(srcCount - chunkStart, CHUNK_SIZE); // Allocate a two-keyframe prefix for all chunks after the first.\n\n    const prefixCount = chunkStart > 0 ? 2 : 0;\n    const chunkInput = new Float32Array(input.buffer, input.byteOffset + (chunkStart - prefixCount) * Float32Array.BYTES_PER_ELEMENT, chunkCount + prefixCount);\n    const chunkOutput = new Float32Array(output.buffer, output.byteOffset + (chunkStart - prefixCount) * outputSize * Float32Array.BYTES_PER_ELEMENT, (chunkCount + prefixCount) * outputSize); // Copy prefix to start of next chunk.\n\n    if (prefixCount > 0) {\n      input.copyWithin(chunkStart - prefixCount, dstCount - prefixCount, dstCount);\n      output.copyWithin((chunkStart - prefixCount) * outputSize, (dstCount - prefixCount) * outputSize, dstCount * outputSize);\n    }\n\n    const inputPtr = __retain(__lowerStaticArray(chunkInput, 4, 2));\n\n    const outputPtr = __retain(__lowerStaticArray(chunkOutput, 4, 2));\n\n    try {\n      exports.__setArgumentsLength(4);\n\n      const count = exports.resample(inputPtr, outputPtr, interpVal, tolerance) >>> 0;\n      dstCount -= prefixCount;\n\n      __liftStaticArray(inputPtr, input, dstCount, count);\n\n      __liftStaticArray(outputPtr, output, dstCount * outputSize, count * outputSize);\n\n      dstCount += count;\n    } finally {\n      __release(inputPtr);\n\n      __release(outputPtr);\n\n      exports.__collect();\n    }\n  } // console.log(`Memory: ${exports.memory.buffer.byteLength} bytes`);\n\n\n  return dstCount;\n} ///////////////////////////////////////////////////////////////////////////////\n// INTERNAL\n///////////////////////////////////////////////////////////////////////////////\n\nfunction __assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction __retain(ptr) {\n  exports.__pin(ptr);\n\n  return ptr;\n}\n\nfunction __release(ptr) {\n  exports.__unpin(ptr);\n\n  return ptr;\n}\n\nfunction __liftString(ptr) {\n  if (!ptr) return null;\n  const end = ptr + new Uint32Array(exports.memory.buffer)[ptr - 4 >>> 2] >>> 1,\n        memoryU16 = new Uint16Array(exports.memory.buffer);\n  let start = ptr >>> 1,\n      string = '';\n\n  while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));\n\n  return string + String.fromCharCode(...memoryU16.subarray(start, end));\n}\n\nfunction __lowerStaticArray(values, id, align) {\n  const ptr = exports.__pin(exports.__new(values.length << align, id)) >>> 0;\n  new Float32Array(exports.memory.buffer, ptr, values.length).set(values);\n\n  exports.__unpin(ptr);\n\n  return ptr;\n}\n\nfunction __liftStaticArray(ptr, values, offset, count) {\n  values.set(new Float32Array(exports.memory.buffer, ptr, count), offset);\n}\n\nfunction __abort(messagePtr, fileNamePtr, lineNumber, columnNumber) {\n  const message = __liftString(messagePtr >>> 0);\n\n  const fileName = __liftString(fileNamePtr >>> 0);\n\n  lineNumber = lineNumber >>> 0;\n  columnNumber = columnNumber >>> 0;\n\n  (() => {\n    throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\n  })();\n}\n\nexport { ready, resample, resampleDebug };\n//# sourceMappingURL=keyframe-resample-browser.modern.js.map\n","import {\n\tAccessor,\n\tAnimationSampler,\n\tComponentTypeToTypedArray,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPropertyType,\n\tRoot,\n\tTransform,\n\tTransformContext,\n\tTypedArray,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup.js';\nimport { createTransform, isTransformPending } from './utils.js';\nimport { resampleDebug } from 'keyframe-resample';\n\nconst NAME = 'resample';\n\nconst EMPTY_ARRAY = new Float32Array(0);\n\nexport interface ResampleOptions {\n\tready?: Promise<void>;\n\tresample?: unknown; // glTF-Transform/issues/996\n\ttolerance?: number;\n}\n\nconst RESAMPLE_DEFAULTS: Required<ResampleOptions> = {\n\tready: Promise.resolve(),\n\tresample: resampleDebug,\n\ttolerance: 1e-4,\n};\n\n/**\n * Resample {@link AnimationChannel AnimationChannels}, losslessly deduplicating keyframes to\n * reduce file size. Duplicate keyframes are commonly present in animation 'baked' by the\n * authoring software to apply IK constraints or other software-specific features.\n *\n * Optionally, a WebAssembly implementation from the\n * [`keyframe-resample`](https://github.com/donmccurdy/keyframe-resample-wasm) library may be\n * provided. The WebAssembly version is usually much faster at processing large animation\n * sequences, but may not be compatible with all runtimes and JavaScript build tools.\n *\n * Result: (0,0,0,0,1,1,1,0,0,0,0,0,0,0) → (0,0,1,1,0,0)\n *\n * Example:\n *\n * ```\n * import { resample } from '@gltf-transform/functions';\n * import { ready, resample as resampleWASM } from 'keyframe-resample';\n *\n * // JavaScript (slower)\n * await document.transform(resample());\n *\n * // WebAssembly (faster)\n * await document.transform(resample({ ready, resample: resampleWASM }));\n * ```\n *\n * @privateRemarks Implementation based on THREE.KeyframeTrack#optimize().\n * @category Transforms\n */\nexport function resample(_options: ResampleOptions = RESAMPLE_DEFAULTS): Transform {\n\tconst options = { ...RESAMPLE_DEFAULTS, ..._options } as Required<ResampleOptions>;\n\n\treturn createTransform(NAME, async (document: Document, context?: TransformContext): Promise<void> => {\n\t\tconst accessorsVisited = new Set<Accessor>();\n\t\tconst srcAccessorCount = document.getRoot().listAccessors().length;\n\t\tconst logger = document.getLogger();\n\n\t\tconst ready = options.ready;\n\t\tconst resample = options.resample as typeof resampleDebug;\n\n\t\tawait ready;\n\n\t\tfor (const animation of document.getRoot().listAnimations()) {\n\t\t\tconst samplerTargetPaths = new Map<AnimationSampler, GLTF.AnimationChannelTargetPath>();\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tsamplerTargetPaths.set(channel.getSampler()!, channel.getTargetPath()!);\n\t\t\t}\n\n\t\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\t\tconst samplerInterpolation = sampler.getInterpolation();\n\n\t\t\t\tif (samplerInterpolation === 'STEP' || samplerInterpolation === 'LINEAR') {\n\t\t\t\t\tconst input = sampler.getInput()!;\n\t\t\t\t\tconst output = sampler.getOutput()!;\n\n\t\t\t\t\taccessorsVisited.add(input);\n\t\t\t\t\taccessorsVisited.add(output);\n\n\t\t\t\t\t// prettier-ignore\n\t\t\t\t\tconst tmpTimes = toFloat32Array(\n\t\t\t\t\t\tinput.getArray()!,\n\t\t\t\t\t\tinput.getComponentType(),\n\t\t\t\t\t\tinput.getNormalized()\n\t\t\t\t\t);\n\t\t\t\t\tconst tmpValues = toFloat32Array(\n\t\t\t\t\t\toutput.getArray()!,\n\t\t\t\t\t\toutput.getComponentType(),\n\t\t\t\t\t\toutput.getNormalized(),\n\t\t\t\t\t);\n\n\t\t\t\t\tconst elementSize = tmpValues.length / tmpTimes.length;\n\t\t\t\t\tconst srcCount = tmpTimes.length;\n\t\t\t\t\tlet dstCount: number;\n\n\t\t\t\t\tif (samplerInterpolation === 'STEP') {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'step', options.tolerance);\n\t\t\t\t\t} else if (samplerTargetPaths.get(sampler) === 'rotation') {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'slerp', options.tolerance);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'lerp', options.tolerance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dstCount < srcCount) {\n\t\t\t\t\t\t// Clone the input/output accessors, without cloning their underlying\n\t\t\t\t\t\t// arrays. Then assign the resampled data.\n\t\t\t\t\t\tconst srcTimes = input.getArray()!;\n\t\t\t\t\t\tconst srcValues = output.getArray()!;\n\n\t\t\t\t\t\tconst dstTimes = fromFloat32Array(\n\t\t\t\t\t\t\tnew Float32Array(tmpTimes.buffer, tmpTimes.byteOffset, dstCount),\n\t\t\t\t\t\t\tinput.getComponentType(),\n\t\t\t\t\t\t\tinput.getNormalized(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst dstValues = fromFloat32Array(\n\t\t\t\t\t\t\tnew Float32Array(tmpValues.buffer, tmpValues.byteOffset, dstCount * elementSize),\n\t\t\t\t\t\t\toutput.getComponentType(),\n\t\t\t\t\t\t\toutput.getNormalized(),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tinput.setArray(EMPTY_ARRAY);\n\t\t\t\t\t\toutput.setArray(EMPTY_ARRAY);\n\n\t\t\t\t\t\tsampler.setInput(input.clone().setArray(dstTimes));\n\t\t\t\t\t\tsampler.setOutput(output.clone().setArray(dstValues));\n\n\t\t\t\t\t\tinput.setArray(srcTimes);\n\t\t\t\t\t\toutput.setArray(srcValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const accessor of Array.from(accessorsVisited.values())) {\n\t\t\tconst used = accessor.listParents().some((p) => !(p instanceof Root));\n\t\t\tif (!used) accessor.dispose();\n\t\t}\n\n\t\t// Resampling may result in duplicate input or output sampler\n\t\t// accessors. Find and remove the duplicates after processing.\n\t\tconst dstAccessorCount = document.getRoot().listAccessors().length;\n\t\tif (dstAccessorCount > srcAccessorCount && !isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** Returns a copy of the source array, as a denormalized Float32Array. */\nfunction toFloat32Array(\n\tsrcArray: TypedArray,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): Float32Array {\n\tif (srcArray instanceof Float32Array) return srcArray.slice();\n\tconst dstArray = new Float32Array(srcArray);\n\tif (!normalized) return dstArray;\n\n\tfor (let i = 0; i < dstArray.length; i++) {\n\t\tdstArray[i] = MathUtils.decodeNormalizedInt(dstArray[i], componentType);\n\t}\n\n\treturn dstArray;\n}\n\n/** Returns a copy of the source array, with specified component type and normalization. */\nfunction fromFloat32Array(\n\tsrcArray: Float32Array,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): TypedArray {\n\tif (componentType === Accessor.ComponentType.FLOAT) return srcArray.slice();\n\tconst TypedArray = ComponentTypeToTypedArray[componentType];\n\tconst dstArray = new TypedArray(srcArray.length);\n\n\tfor (let i = 0; i < dstArray.length; i++) {\n\t\tdstArray[i] = normalized ? MathUtils.encodeNormalizedInt(srcArray[i], componentType) : srcArray[i];\n\t}\n\n\treturn dstArray;\n}\n","import { Accessor, AnimationChannel, AnimationSampler, Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\t/** Frames per second, where one node is shown each frame. Default 10. */\n\tfps?: number;\n\t/** Pattern (regex) used to filter nodes for the sequence. Required. */\n\tpattern: RegExp;\n\t/** Name of the new animation. */\n\tname?: string;\n\t/** Whether to sort the nodes by name, or use original order. Default true. */\n\tsort?: boolean;\n}\n\nconst SEQUENCE_DEFAULTS: Required<SequenceOptions> = {\n\tname: '',\n\tfps: 10,\n\tpattern: /.*/,\n\tsort: true,\n};\n\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n *\n * @category Transforms\n */\nexport function sequence(_options: SequenceOptions = SEQUENCE_DEFAULTS): Transform {\n\tconst options = { ...SEQUENCE_DEFAULTS, ..._options } as Required<SequenceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes().filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => (a.getName() > b.getName() ? 1 : -1));\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1, 1, 1, 0, 0, 0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor().setArray(new Float32Array(inputArray)).setBuffer(animBuffer);\n\t\t\tconst output = doc\n\t\t\t\t.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(Accessor.Type.VEC3);\n\t\t\tconst sampler = doc\n\t\t\t\t.createAnimationSampler()\n\t\t\t\t.setInterpolation(AnimationSampler.Interpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc\n\t\t\t\t.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(AnimationChannel.TargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import { Accessor, Document, Primitive, PropertyType, Transform, TransformContext } from '@gltf-transform/core';\nimport {\n\tcreateTransform,\n\tformatDeltaOp,\n\tdeepListAttributes,\n\tremapAttribute,\n\tdeepSwapAttribute,\n\tisTransformPending,\n} from './utils.js';\nimport { weld } from './weld.js';\nimport type { MeshoptSimplifier } from 'meshoptimizer';\nimport { dedup } from './dedup.js';\nimport { prune } from './prune.js';\n\nconst NAME = 'simplify';\n\n/** Options for the {@link simplify} function. */\nexport interface SimplifyOptions {\n\t/** MeshoptSimplifier instance. */\n\tsimplifier: unknown;\n\t/** Target ratio (0–1) of vertices to keep. Default: 0.0 (0%). */\n\tratio?: number;\n\t/** Limit on error, as a fraction of mesh radius. Default: 0.0001 (0.01%). */\n\terror?: number;\n\t/**\n\t * Whether to lock topological borders of the mesh. May be necessary when\n\t * adjacent 'chunks' of a large mesh (e.g. terrain) share a border, helping\n\t * to ensure no seams appear.\n\t */\n\tlockBorder?: boolean;\n}\n\nexport const SIMPLIFY_DEFAULTS: Required<Omit<SimplifyOptions, 'simplifier'>> = {\n\tratio: 0.0,\n\terror: 0.0001,\n\tlockBorder: false,\n};\n\n/**\n * Simplification algorithm, based on meshoptimizer, producing meshes with fewer\n * triangles and vertices. Simplification is lossy, but the algorithm aims to\n * preserve visual quality as much as possible for given parameters.\n *\n * The algorithm aims to reach the target 'ratio', while minimizing error. If\n * error exceeds the specified 'error' threshold, the algorithm will quit\n * before reaching the target ratio. Examples:\n *\n * - ratio=0.0, error=0.0001: Aims for maximum simplification, constrained to 0.01% error.\n * - ratio=0.5, error=0.0001: Aims for 50% simplification, constrained to 0.01% error.\n * - ratio=0.5, error=1: Aims for 50% simplification, unconstrained by error.\n *\n * Topology, particularly split vertices, will also limit the simplifier. For\n * best results, apply a {@link weld} operation before simplification.\n *\n * Example:\n *\n * ```javascript\n * import { simplify, weld } from '@gltf-transform/functions';\n * import { MeshoptSimplifier } from 'meshoptimizer';\n *\n * await document.transform(\n *   weld({ tolerance: 0.0001 }),\n *   simplify({ simplifier: MeshoptSimplifier, ratio: 0.75, error: 0.001 })\n * );\n * ```\n *\n * References:\n * - https://github.com/zeux/meshoptimizer/blob/master/js/README.md#simplifier\n *\n * @category Transforms\n */\nexport function simplify(_options: SimplifyOptions): Transform {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier | undefined;\n\n\tif (!simplifier) {\n\t\tthrow new Error(`${NAME}: simplifier dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document, context?: TransformContext): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tawait simplifier.ready;\n\t\tawait document.transform(weld({ overwrite: false }));\n\n\t\t// Simplify mesh primitives.\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tif (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`${NAME}: Skipping primitive of mesh \"${mesh.getName()}\": Requires TRIANGLES draw mode.`,\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsimplifyPrimitive(document, prim, options);\n\n\t\t\t\tif (prim.getIndices()!.getCount() === 0) prim.dispose();\n\t\t\t}\n\n\t\t\tif (mesh.listPrimitives().length === 0) mesh.dispose();\n\t\t}\n\n\t\t// Where simplification removes meshes, we may need to prune leaf nodes.\n\t\tawait document.transform(\n\t\t\tprune({\n\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.NODE],\n\t\t\t\tkeepAttributes: true,\n\t\t\t\tkeepIndices: true,\n\t\t\t\tkeepLeaves: false,\n\t\t\t}),\n\t\t);\n\n\t\t// Where multiple primitive indices point into the same vertex streams, simplification\n\t\t// may write duplicate streams. Find and remove the duplicates after processing.\n\t\tif (!isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nexport function simplifyPrimitive(document: Document, prim: Primitive, _options: SimplifyOptions): Primitive {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier;\n\n\tconst logger = document.getLogger();\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices()!;\n\tconst srcVertexCount = position.getCount();\n\n\tlet positionArray = position.getArray()!;\n\tlet indicesArray = srcIndices.getArray()!;\n\n\t// (1) Gather attributes and indices in Meshopt-compatible format.\n\n\tif (position.getComponentType() !== Accessor.ComponentType.FLOAT) {\n\t\tif (position.getNormalized()) {\n\t\t\tconst src = positionArray;\n\t\t\tconst dst = new Float32Array(src.length);\n\n\t\t\t// Dequantize.\n\t\t\tfor (let i = 0, il = position.getCount(), el = [] as number[]; i < il; i++) {\n\t\t\t\tel = position.getElement(i, el);\n\t\t\t\tposition.setArray(dst).setElement(i, el).setArray(src);\n\t\t\t}\n\n\t\t\tpositionArray = dst;\n\t\t} else {\n\t\t\tpositionArray = new Float32Array(positionArray);\n\t\t}\n\t}\n\n\tif (srcIndices.getComponentType() !== Accessor.ComponentType.UNSIGNED_INT) {\n\t\tindicesArray = new Uint32Array(indicesArray);\n\t}\n\n\t// (2) Run simplification.\n\n\tconst targetCount = Math.floor((options.ratio * srcVertexCount) / 3) * 3;\n\tconst [dstIndicesArray, error] = simplifier.simplify(\n\t\tindicesArray as Uint32Array,\n\t\tpositionArray as Float32Array,\n\t\t3,\n\t\ttargetCount,\n\t\toptions.error,\n\t\toptions.lockBorder ? ['LockBorder'] : [],\n\t);\n\n\tconst [remap, unique] = simplifier.compactMesh(dstIndicesArray);\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(position.getCount(), unique)} vertices, error: ${error.toFixed(4)}.`);\n\n\t// (3) Write vertex attributes.\n\n\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\tconst dstAttribute = srcAttribute.clone();\n\t\tremapAttribute(dstAttribute, remap, unique);\n\t\tdeepSwapAttribute(prim, srcAttribute, dstAttribute);\n\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t}\n\n\t// (4) Write indices.\n\n\tconst dstIndices = srcIndices.clone();\n\tdstIndices.setArray(srcVertexCount <= 65534 ? new Uint16Array(dstIndicesArray) : dstIndicesArray);\n\tprim.setIndices(dstIndices);\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\n\treturn prim;\n}\n","import { Document, MathUtils, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'sparse';\n\n/** Options for the {@link sparse} function. */\nexport interface SparseOptions {\n\t/**\n\t * Threshold ratio used to determine when an accessor should be sparse.\n\t * Default: 1 / 3.\n\t */\n\tratio: number;\n}\n\nconst SPARSE_DEFAULTS: Required<SparseOptions> = {\n\tratio: 1 / 3,\n};\n\n/**\n * Scans all {@link Accessor Accessors} in the Document, detecting whether each Accessor\n * would benefit from sparse data storage. Currently, sparse data storage is used only\n * when many values (>= ratio) are zeroes. Particularly for assets using morph target\n * (\"shape key\") animation, sparse data storage may significantly reduce file sizes.\n *\n * Example:\n *\n * ```ts\n * import { sparse } from '@gltf-transform/functions';\n *\n * accessor.getArray(); // → [ 0, 0, 0, 0, 0, 25.0, 0, 0, ... ]\n * accessor.getSparse(); // → false\n *\n * await document.transform(sparse({ratio: 1 / 10}));\n *\n * accessor.getSparse(); // → true\n * ```\n *\n * @experimental\n * @category Transforms\n */\nexport function sparse(_options: SparseOptions = SPARSE_DEFAULTS): Transform {\n\tconst options = { ...SPARSE_DEFAULTS, ..._options } as Required<SparseOptions>;\n\n\tconst ratio = options.ratio;\n\tif (ratio < 0 || ratio > 1) {\n\t\tthrow new Error(`${NAME}: Ratio must be between 0 and 1.`);\n\t}\n\n\treturn createTransform(NAME, (document: Document): void => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\tlet modifiedCount = 0;\n\n\t\tfor (const accessor of root.listAccessors()) {\n\t\t\tconst count = accessor.getCount();\n\t\t\tconst base = Array(accessor.getElementSize()).fill(0);\n\t\t\tconst el = Array(accessor.getElementSize()).fill(0);\n\n\t\t\tlet nonZeroCount = 0;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\taccessor.getElement(i, el);\n\t\t\t\tif (!MathUtils.eq(el, base, 0)) nonZeroCount++;\n\t\t\t\tif (nonZeroCount / count >= ratio) break;\n\t\t\t}\n\n\t\t\tconst sparse = nonZeroCount / count < ratio;\n\t\t\tif (sparse !== accessor.getSparse()) {\n\t\t\t\taccessor.setSparse(sparse);\n\t\t\t\tmodifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Updated ${modifiedCount} accessors.`);\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport { MathUtils, type Document, type Transform, type vec2 } from '@gltf-transform/core';\nimport { listTextureSlots } from './list-texture-slots.js';\nimport { createTransform, fitWithin } from './utils.js';\n\nconst NAME = 'textureResize';\n\n/** Options for the {@link textureResize} function. */\nexport interface TextureResizeOptions {\n\t/**\n\t * Maximum width/height to enforce, preserving aspect ratio. For example,\n\t * a 4096x8192 texture, resized with limit [2048, 2048] will be reduced\n\t * to 1024x2048.\n\t */\n\tsize: vec2;\n\t/** Resampling filter method. LANCZOS3 is sharper, LANCZOS2 is smoother. */\n\tfilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to resize, matched to name or URI. */\n\tpattern?: RegExp | null;\n\t/** Pattern to match slots usage for resizing. */\n\tslots?: RegExp | null;\n}\n\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nexport enum TextureResizeFilter {\n\t/** Lanczos3 (sharp) */\n\tLANCZOS3 = 'lanczos3',\n\t/** Lanczos2 (smooth) */\n\tLANCZOS2 = 'lanczos2',\n}\n\nexport const TEXTURE_RESIZE_DEFAULTS: TextureResizeOptions = {\n\tsize: [2048, 2048],\n\tfilter: TextureResizeFilter.LANCZOS3,\n\tpattern: null,\n\tslots: null,\n};\n\n/**\n * Resize PNG or JPEG {@link Texture Textures}, with [Lanczos filtering](https://en.wikipedia.org/wiki/Lanczos_algorithm).\n *\n * Implementation provided by [ndarray-lanczos](https://github.com/donmccurdy/ndarray-lanczos)\n * package, which works in Web and Node.js environments. For a faster and more robust implementation\n * in Node.js, use {@link textureCompress}, providing a Sharp encoder and 'resize' options instead.\n *\n * @deprecated Prefer {@link textureCompress}, instead.\n * @privateRemarks TODO(v4): Remove this function, using `textureCompress()` instead.\n * @category Transforms\n */\nexport function textureResize(_options: TextureResizeOptions = TEXTURE_RESIZE_DEFAULTS): Transform {\n\tconst options = { ...TEXTURE_RESIZE_DEFAULTS, ..._options } as Required<TextureResizeOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const texture of doc.getRoot().listTextures()) {\n\t\t\tconst name = texture.getName();\n\t\t\tconst uri = texture.getURI();\n\t\t\tconst match = !options.pattern || options.pattern.test(name) || options.pattern.test(uri);\n\t\t\tif (!match) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, excluded by \"pattern\" parameter.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (texture.getMimeType() !== 'image/png' && texture.getMimeType() !== 'image/jpeg') {\n\t\t\t\tlogger.warn(`${NAME}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst slots = listTextureSlots(texture);\n\t\t\tif (options.slots && !slots.some((slot) => options.slots?.test(slot))) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst srcSize = texture.getSize()!;\n\t\t\tconst dstSize = fitWithin(srcSize, options.size);\n\n\t\t\tif (MathUtils.eq(srcSize, dstSize)) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, not within size range.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst srcImage = texture.getImage()!;\n\t\t\tconst srcPixels = (await getPixels(srcImage, texture.getMimeType())) as ndarray.NdArray<Uint8Array>;\n\t\t\tconst dstPixels = ndarray(new Uint8Array(dstSize[0] * dstSize[1] * 4), [...dstSize, 4]);\n\n\t\t\tlogger.debug(`${NAME}: Resizing \"${uri || name}\", ${srcPixels.shape} → ${dstPixels.shape}...`);\n\t\t\tlogger.debug(`${NAME}: Slots → [${slots.join(', ')}]`);\n\n\t\t\ttry {\n\t\t\t\toptions.filter === TextureResizeFilter.LANCZOS3\n\t\t\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof Error) {\n\t\t\t\t\tlogger.warn(`${NAME}: Failed to resize \"${uri || name}\": \"${e.message}\".`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\ttexture.setImage(await savePixels(dstPixels, texture.getMimeType()));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import { BufferUtils, Document, ImageUtils, Texture, TextureChannel, Transform, vec2 } from '@gltf-transform/core';\nimport { EXTTextureAVIF, EXTTextureWebP } from '@gltf-transform/extensions';\nimport { getTextureChannelMask } from './list-texture-channels.js';\nimport { listTextureSlots } from './list-texture-slots.js';\nimport type sharp from 'sharp';\nimport { createTransform, fitWithin, formatBytes } from './utils.js';\nimport { TextureResizeFilter } from './texture-resize.js';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\n\nconst NAME = 'textureCompress';\n\ntype Format = (typeof TEXTURE_COMPRESS_SUPPORTED_FORMATS)[number];\nexport const TEXTURE_COMPRESS_SUPPORTED_FORMATS = ['jpeg', 'png', 'webp', 'avif'] as const;\nconst SUPPORTED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];\n\nexport interface TextureCompressOptions {\n\t/** Instance of the Sharp encoder, which must be installed from the\n\t * 'sharp' package and provided by the caller. When not provided, a\n\t * platform-specific fallback implementation will be used, and most\n\t * quality- and compression-related options are ignored.\n\t */\n\tencoder?: unknown;\n\t/**\n\t * Target image format. If specified, included textures in other formats\n\t * will be converted. Default: original format.\n\t */\n\ttargetFormat?: Format;\n\t/**\n\t * Resizes textures to given maximum width/height, preserving aspect ratio.\n\t * For example, a 4096x8192 texture, resized with limit [2048, 2048] will\n\t * be reduced to 1024x2048.\n\t */\n\tresize?: vec2;\n\t/** Interpolation used if resizing. Default: TextureResizeFilter.LANCZOS3. */\n\tresizeFilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to compress, matched to name or URI. */\n\tpattern?: RegExp | null;\n\t/**\n\t * Pattern matching the format(s) to be compressed or converted. Some examples\n\t * of formats include \"jpeg\" and \"png\".\n\t */\n\tformats?: RegExp | null;\n\t/**\n\t * Pattern matching the material texture slot(s) to be compressed or converted.\n\t * Some examples of slot names include \"baseColorTexture\", \"occlusionTexture\",\n\t * \"metallicRoughnessTexture\", and \"normalTexture\".\n\t */\n\tslots?: RegExp | null;\n\n\t/** Quality, 1-100. Default: auto. */\n\tquality?: number | null;\n\t/**\n\t * Level of CPU effort to reduce file size, 0-100. PNG, WebP, and AVIF\n\t * only. Supported only when a Sharp encoder is provided. Default: auto.\n\t */\n\teffort?: number | null;\n\t/**\n\t * Use lossless compression mode. WebP and AVIF only. Supported only when a\n\t * Sharp encoder is provided. Default: false.\n\t */\n\tlossless?: boolean;\n\t/**\n\t * Use near lossless compression mode. WebP only. Supported only when a\n\t * Sharp encoder is provided. Default: false.\n\t */\n\tnearLossless?: boolean;\n}\n\nexport type CompressTextureOptions = Omit<TextureCompressOptions, 'pattern' | 'formats' | 'slots'>;\n\n// IMPORTANT: No defaults for quality flags, see https://github.com/donmccurdy/glTF-Transform/issues/969.\nexport const TEXTURE_COMPRESS_DEFAULTS: Omit<TextureCompressOptions, 'resize' | 'targetFormat' | 'encoder'> = {\n\tresizeFilter: TextureResizeFilter.LANCZOS3,\n\tpattern: undefined,\n\tformats: undefined,\n\tslots: undefined,\n\tquality: undefined,\n\teffort: undefined,\n\tlossless: false,\n\tnearLossless: false,\n};\n\n/**\n * Optimizes images, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted — `sharp` works only in Node.js —\n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { textureCompress } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * // (A) Optimize without conversion.\n * await document.transform(\n * \ttextureCompress({encoder: sharp})\n * );\n *\n * // (B) Optimize and convert images to WebP.\n * await document.transform(\n * \ttextureCompress({\n * \t\tencoder: sharp,\n * \t\ttargetFormat: 'webp',\n * \t\tslots: /^(?!normalTexture).*$/ // exclude normal maps\n * \t})\n * );\n *\n * // (C) Resize and convert images to WebP in a browser, without a Sharp\n * // encoder. Most quality- and compression-related options are ignored.\n * await document.transform(\n * \ttextureCompress({ targetFormat: 'webp', resize: [1024, 1024] })\n * );\n * ```\n *\n * @category Transforms\n */\nexport function textureCompress(_options: TextureCompressOptions): Transform {\n\tconst options = { ...TEXTURE_COMPRESS_DEFAULTS, ..._options } as Required<TextureCompressOptions>;\n\tconst targetFormat = options.targetFormat as Format | undefined;\n\tconst patternRe = options.pattern;\n\tconst formatsRe = options.formats;\n\tconst slotsRe = options.slots;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst textures = document.getRoot().listTextures();\n\n\t\tawait Promise.all(\n\t\t\ttextures.map(async (texture, textureIndex) => {\n\t\t\t\tconst slots = listTextureSlots(texture);\n\t\t\t\tconst channels = getTextureChannelMask(texture);\n\t\t\t\tconst textureLabel =\n\t\t\t\t\ttexture.getURI() ||\n\t\t\t\t\ttexture.getName() ||\n\t\t\t\t\t`${textureIndex + 1}/${document.getRoot().listTextures().length}`;\n\t\t\t\tconst prefix = `${NAME}(${textureLabel})`;\n\n\t\t\t\t// FILTER: Exclude textures that don't match (a) 'slots' or (b) expected formats.\n\n\t\t\t\tif (!SUPPORTED_MIME_TYPES.includes(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (patternRe && !patternRe.test(texture.getName()) && !patternRe.test(texture.getURI())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, excluded by \"pattern\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (formatsRe && !formatsRe.test(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, \"${texture.getMimeType()}\" excluded by \"formats\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (slotsRe && slots.length && !slots.some((slot) => slotsRe.test(slot))) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (options.targetFormat === 'jpeg' && channels & TextureChannel.A) {\n\t\t\t\t\tlogger.warn(`${prefix}: Skipping, [${slots.join(', ')}] requires alpha channel.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst srcFormat = getFormat(texture);\n\t\t\t\tconst dstFormat = targetFormat || srcFormat;\n\t\t\t\tlogger.debug(`${prefix}: Format = ${srcFormat} → ${dstFormat}`);\n\t\t\t\tlogger.debug(`${prefix}: Slots = [${slots.join(', ')}]`);\n\n\t\t\t\tconst srcImage = texture.getImage()!;\n\t\t\t\tconst srcByteLength = srcImage.byteLength;\n\n\t\t\t\tawait compressTexture(texture, options);\n\n\t\t\t\tconst dstImage = texture.getImage()!;\n\t\t\t\tconst dstByteLength = dstImage.byteLength;\n\n\t\t\t\tconst flag = srcImage === dstImage ? ' (SKIPPED' : '';\n\n\t\t\t\tlogger.debug(`${prefix}: Size = ${formatBytes(srcByteLength)} → ${formatBytes(dstByteLength)}${flag}`);\n\t\t\t}),\n\t\t);\n\n\t\t// Attach EXT_texture_webp if needed.\n\t\tconst webpExtension = document.createExtension(EXTTextureWebP);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/webp')) {\n\t\t\twebpExtension.setRequired(true);\n\t\t} else {\n\t\t\twebpExtension.dispose();\n\t\t}\n\n\t\t// Attach EXT_texture_avif if needed.\n\t\tconst avifExtension = document.createExtension(EXTTextureAVIF);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/avif')) {\n\t\t\tavifExtension.setRequired(true);\n\t\t} else {\n\t\t\tavifExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Optimizes a single {@link Texture}, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted — `sharp` works only in Node.js —\n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { compressTexture } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * const texture = document.getRoot().listTextures()\n * \t.find((texture) => texture.getName() === 'MyTexture');\n *\n * // (A) Node.js.\n * await compressTexture(texture, {\n * \tencoder: sharp,\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n *\n * // (B) Web.\n * await compressTexture(texture, {\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n * ```\n */\nexport async function compressTexture(texture: Texture, _options: CompressTextureOptions) {\n\tconst options = { ...TEXTURE_COMPRESS_DEFAULTS, ..._options } as Required<CompressTextureOptions>;\n\tconst encoder = options.encoder as typeof sharp | null;\n\n\tconst srcFormat = getFormat(texture);\n\tconst dstFormat = options.targetFormat || srcFormat;\n\tconst srcMimeType = texture.getMimeType();\n\tconst dstMimeType = `image/${dstFormat}`;\n\n\tconst srcImage = texture.getImage()!;\n\tconst dstImage = encoder\n\t\t? await _encodeWithSharp(srcImage, srcMimeType, dstMimeType, options)\n\t\t: await _encodeWithNdarrayPixels(srcImage, srcMimeType, dstMimeType, options);\n\n\tconst srcByteLength = srcImage.byteLength;\n\tconst dstByteLength = dstImage.byteLength;\n\n\tif (srcMimeType === dstMimeType && dstByteLength >= srcByteLength && !options.resize) {\n\t\t// Skip if src/dst formats match and dst is larger than the original.\n\t\treturn;\n\t} else if (srcMimeType === dstMimeType) {\n\t\t// Overwrite if src/dst formats match and dst is smaller than the original.\n\t\ttexture.setImage(dstImage);\n\t} else {\n\t\t// Overwrite, then update path and MIME type if src/dst formats differ.\n\t\tconst srcExtension = ImageUtils.mimeTypeToExtension(srcMimeType);\n\t\tconst dstExtension = ImageUtils.mimeTypeToExtension(dstMimeType);\n\t\tconst dstURI = texture.getURI().replace(new RegExp(`\\\\.${srcExtension}$`), `.${dstExtension}`);\n\t\ttexture.setImage(dstImage).setMimeType(dstMimeType).setURI(dstURI);\n\t}\n}\n\nasync function _encodeWithSharp(\n\tsrcImage: Uint8Array,\n\t_srcMimeType: string,\n\tdstMimeType: string,\n\toptions: Required<CompressTextureOptions>,\n): Promise<Uint8Array> {\n\tconst encoder = options.encoder as typeof sharp;\n\tlet encoderOptions: sharp.JpegOptions | sharp.PngOptions | sharp.WebpOptions | sharp.AvifOptions = {};\n\n\tconst dstFormat = getFormatFromMimeType(dstMimeType);\n\n\tswitch (dstFormat) {\n\t\tcase 'jpeg':\n\t\t\tencoderOptions = { quality: options.quality } as sharp.JpegOptions;\n\t\t\tbreak;\n\t\tcase 'png':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 10),\n\t\t\t} as sharp.PngOptions;\n\t\t\tbreak;\n\t\tcase 'webp':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 6),\n\t\t\t\tlossless: options.lossless,\n\t\t\t\tnearLossless: options.nearLossless,\n\t\t\t} as sharp.WebpOptions;\n\t\t\tbreak;\n\t\tcase 'avif':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 9),\n\t\t\t\tlossless: options.lossless,\n\t\t\t} as sharp.AvifOptions;\n\t\t\tbreak;\n\t}\n\n\tconst instance = encoder(srcImage).toFormat(dstFormat, encoderOptions);\n\n\tif (options.resize) {\n\t\tinstance.resize(options.resize[0], options.resize[1], {\n\t\t\tfit: 'inside',\n\t\t\tkernel: options.resizeFilter,\n\t\t\twithoutEnlargement: true,\n\t\t});\n\t}\n\n\treturn BufferUtils.toView(await instance.toBuffer());\n}\n\nasync function _encodeWithNdarrayPixels(\n\tsrcImage: Uint8Array,\n\tsrcMimeType: string,\n\tdstMimeType: string,\n\toptions: Required<CompressTextureOptions>,\n): Promise<Uint8Array> {\n\tconst srcPixels = (await getPixels(srcImage, srcMimeType)) as ndarray.NdArray<Uint8Array>;\n\n\tif (options.resize) {\n\t\tconst [w, h] = srcPixels.shape;\n\t\tconst dstSize = fitWithin([w, h], options.resize);\n\t\tconst dstPixels = ndarray(new Uint8Array(dstSize[0] * dstSize[1] * 4), [...dstSize, 4]);\n\t\toptions.resizeFilter === TextureResizeFilter.LANCZOS3\n\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\treturn savePixels(dstPixels, dstMimeType);\n\t}\n\n\treturn savePixels(srcPixels, dstMimeType);\n}\n\nfunction getFormat(texture: Texture): Format {\n\treturn getFormatFromMimeType(texture.getMimeType());\n}\n\nfunction getFormatFromMimeType(mimeType: string): Format {\n\tconst format = mimeType.split('/').pop() as Format | undefined;\n\tif (!format || !TEXTURE_COMPRESS_SUPPORTED_FORMATS.includes(format)) {\n\t\tthrow new Error(`Unknown MIME type \"${mimeType}\".`);\n\t}\n\treturn format;\n}\n\nfunction remap(value: number | null | undefined, srcMax: number, dstMax: number): number | undefined {\n\tif (value == null) return undefined;\n\treturn Math.round((value / srcMax) * dstMax);\n}\n","import { Accessor, Document, ILogger, Primitive, Transform, TypedArray, uuid } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'tangents';\n\n/** Options for the {@link tangents} function. */\nexport interface TangentsOptions {\n\t/**\n\t * Callback function to generate tangents from position, uv, and normal attributes.\n\t * Generally, users will want to provide the `generateTangents` from the\n\t * [mikktspace](https://github.com/donmccurdy/mikktspace-wasm) library, which is not\n\t * included by default.\n\t */\n\tgenerateTangents?: (pos: Float32Array, norm: Float32Array, uv: Float32Array) => Float32Array;\n\t/** Whether to overwrite existing `TANGENT` attributes. */\n\toverwrite?: boolean;\n}\n\nconst TANGENTS_DEFAULTS: Required<Omit<TangentsOptions, 'generateTangents'>> = {\n\toverwrite: false,\n};\n\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occuring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function tangents(_options: TangentsOptions = TANGENTS_DEFAULTS): Transform {\n\tif (!_options.generateTangents) {\n\t\tthrow new Error(`${NAME}: generateTangents callback required — install \"mikktspace\".`);\n\t}\n\n\tconst options = { ...TANGENTS_DEFAULTS, ..._options } as Required<TangentsOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst attributeIDs = new Map<TypedArray, string>();\n\t\tconst tangentCache = new Map<string, Accessor>();\n\t\tlet modified = 0;\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tconst meshName = mesh.getName();\n\t\t\tconst meshPrimitives = mesh.listPrimitives();\n\n\t\t\tfor (let i = 0; i < meshPrimitives.length; i++) {\n\t\t\t\tconst prim = meshPrimitives[i];\n\n\t\t\t\t// Skip primitives for which we can't compute tangents.\n\t\t\t\tif (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n\n\t\t\t\tconst texcoordSemantic = getNormalTexcoord(prim);\n\n\t\t\t\t// Nullability conditions checked by filterPrimitive() above.\n\t\t\t\tconst position = prim.getAttribute('POSITION')!.getArray()!;\n\t\t\t\tconst normal = prim.getAttribute('NORMAL')!.getArray()!;\n\t\t\t\tconst texcoord = prim.getAttribute(texcoordSemantic)!.getArray()!;\n\n\t\t\t\t// Compute UUIDs for each attribute.\n\t\t\t\tconst positionID = attributeIDs.get(position) || uuid();\n\t\t\t\tattributeIDs.set(position, positionID);\n\n\t\t\t\tconst normalID = attributeIDs.get(normal) || uuid();\n\t\t\t\tattributeIDs.set(normal, normalID);\n\n\t\t\t\tconst texcoordID = attributeIDs.get(texcoord) || uuid();\n\t\t\t\tattributeIDs.set(texcoord, texcoordID);\n\n\t\t\t\t// Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n\t\t\t\tconst prevTangent = prim.getAttribute('TANGENT');\n\t\t\t\tif (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n\n\t\t\t\t// If we've already computed tangents for this pos/norm/uv set, reuse them.\n\t\t\t\tconst attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n\t\t\t\tlet tangent = tangentCache.get(attributeHash);\n\t\t\t\tif (tangent) {\n\t\t\t\t\tlogger.debug(`${NAME}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\t\t\t\t\tmodified++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, generate tangents with the 'mikktspace' WASM library.\n\t\t\t\tlogger.debug(`${NAME}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\tconst tangentBuffer = prim.getAttribute('POSITION')!.getBuffer();\n\t\t\t\tconst tangentArray = options.generateTangents(\n\t\t\t\t\tposition instanceof Float32Array ? position : new Float32Array(position),\n\t\t\t\t\tnormal instanceof Float32Array ? normal : new Float32Array(normal),\n\t\t\t\t\ttexcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord)\n\t\t\t\t);\n\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n\t\t\t\tfor (let i = 3; i < tangentArray.length; i += 4) tangentArray[i] *= -1;\n\n\t\t\t\ttangent = doc.createAccessor().setBuffer(tangentBuffer).setArray(tangentArray).setType('VEC4');\n\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\n\t\t\t\ttangentCache.set(attributeHash, tangent);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\nfunction getNormalTexcoord(prim: Primitive): string {\n\tconst material = prim.getMaterial();\n\tif (!material) return 'TEXCOORD_0';\n\n\tconst normalTextureInfo = material.getNormalTextureInfo();\n\tif (!normalTextureInfo) return 'TEXCOORD_0';\n\n\tconst texcoord = normalTextureInfo.getTexCoord();\n\tconst semantic = `TEXCOORD_${texcoord}`;\n\tif (prim.getAttribute(semantic)) return semantic;\n\n\treturn 'TEXCOORD_0';\n}\n\nfunction filterPrimitive(prim: Primitive, logger: ILogger, meshName: string, i: number, overwrite: boolean): boolean {\n\tif (\n\t\tprim.getMode() !== Primitive.Mode.TRIANGLES ||\n\t\t!prim.getAttribute('POSITION') ||\n\t\t!prim.getAttribute('NORMAL') ||\n\t\t!prim.getAttribute('TEXCOORD_0')\n\t) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` +\n\t\t\t\t' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.'\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getAttribute('TANGENT') && !overwrite) {\n\t\tlogger.debug(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`);\n\t\treturn false;\n\t}\n\n\tif (prim.getIndices()) {\n\t\t// TODO(feat): Do this automatically for qualifying primitives.\n\t\tlogger.warn(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` + ' be unwelded.');\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'unpartition';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnpartitionOptions {}\nconst UNPARTITION_DEFAULTS: Required<UnpartitionOptions> = {};\n\n/**\n * Removes partitions from the binary payload of a glTF file, so that the asset\n * contains at most one (1) `.bin` {@link Buffer}. This process reverses the\n * changes from a {@link partition} transform.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n *\n * await document.transform(unpartition());\n *\n * document.getRoot().listBuffers(); // → [Buffer]\n * ```\n *\n * @category Transforms\n */\nexport function unpartition(_options: UnpartitionOptions = UNPARTITION_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...UNPARTITION_DEFAULTS, ..._options } as Required<UnpartitionOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tconst buffer = document.getRoot().listBuffers()[0];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listAccessors()\n\t\t\t.forEach((a) => a.setBuffer(buffer));\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.forEach((b, index) => (index > 0 ? b.dispose() : null));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import type { Accessor, Document, Primitive, Transform, vec3 } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'vertexColorSpace';\n\n/** Options for the {@link vertexColorSpace} function. */\nexport interface ColorSpaceOptions {\n\t/** Input color space of vertex colors, to be converted to \"srgb-linear\". Required. */\n\tinputColorSpace: 'srgb' | 'srgb-linear' | 'sRGB';\n\t/** @deprecated Renamed to 'colorSpace'. */\n\tinputEncoding?: 'srgb' | 'srgb-linear' | 'sRGB';\n}\n\n/** @deprecated Renamed to {@link vertexColorSpace}. */\nexport const colorspace = vertexColorSpace;\n\n/**\n * Vertex color color space correction. The glTF format requires vertex colors to be stored\n * in Linear Rec. 709 D65 color space, and this function provides a way to correct vertex\n * colors that are (incorrectly) stored in sRGB.\n *\n * Example:\n *\n * ```typescript\n * import { vertexColorSpace } from '@gltf-transform/functions';\n *\n * await document.transform(\n *   vertexColorSpace({ inputColorSpace: 'srgb' })\n * );\n * ```\n *\n * @category Transforms\n */\nexport function vertexColorSpace(options: ColorSpaceOptions): Transform {\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst inputColorSpace = (options.inputColorSpace || options.inputEncoding || '').toLowerCase();\n\n\t\tif (inputColorSpace === 'srgb-linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (inputColorSpace !== 'srgb') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input color space \"${inputColorSpace}\" – should be \"srgb\" or ` +\n\t\t\t\t\t'\"srgb-linear\". Skipping conversion.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear(c: number): number {\n\t\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [0, 0, 0] as vec3;\n\t\t\tlet attribute: Accessor | null;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import type { Node, Scene } from '@gltf-transform/core';\nimport { listNodeScenes } from './list-node-scenes.js';\n\n/** @deprecated Use {@link listNodeScenes} instead. */\nexport function getNodeScene(node: Node): Scene | null {\n\treturn listNodeScenes(node)[0] || null;\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRMaterialsUnlit } from '@gltf-transform/extensions';\n\n/**\n * @category Transforms\n */\nexport function unlit(): Transform {\n\treturn (doc: Document): void => {\n\t\tconst unlitExtension = doc.createExtension(KHRMaterialsUnlit) as KHRMaterialsUnlit;\n\t\tconst unlit = unlitExtension.createUnlit();\n\t\tdoc.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tmaterial.setExtension('KHR_materials_unlit', unlit);\n\t\t\t});\n\t};\n}\n"],"names":["rewriteTexture","source","target","fn","Promise","resolve","srcImage","getImage","getPixels","getMimeType","then","pixels","i","shape","j","savePixels","dstImage","setImage","setMimeType","e","reject","createTransform","name","Object","defineProperty","value","isTransformPending","context","initial","pending","stack","lastIndexOf","getGLPrimitiveCount","prim","indices","getIndices","position","getAttribute","getMode","Primitive","Mode","POINTS","getCount","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Error","SetMap","constructor","_map","Map","size","has","k","add","v","entry","this","get","Set","set","keys","formatBytes","bytes","decimals","dm","Math","floor","log","parseFloat","pow","toFixed","formatLong","x","toString","replace","formatDeltaOp","a","b","abs","formatDelta","deepListAttributes","accessors","attribute","listAttributes","push","listTargets","Array","from","deepSwapAttribute","src","dst","swap","shallowEqualsArray","length","remapAttribute","remap","dstCount","elementSize","getElementSize","srcCount","srcArray","getArray","dstArray","slice","setArray","createIndices","count","maxIndex","array","Uint16Array","Uint32Array","createPrimGroupKey","document","Document","fromGraph","getGraph","material","getMaterial","getRoot","listMaterials","indexOf","listSemantics","sort","map","semantic","getComponentType","join","fitWithin","limit","maxWidth","maxHeight","srcWidth","srcHeight","dstWidth","dstHeight","NAME","CENTER_DEFAULTS","pivot","listNodeScenes","node","visited","parent","child","getParentNode","listParents","filter","Scene","clearNodeParent","scenes","setMatrix","getWorldMatrix","removeChild","scene","addChild","ARRAY_TYPE","Float32Array","invert","out","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b00","b01","b02","b03","b04","b05","b06","b07","b08","b09","b10","b11","det","multiply","b0","b1","b2","b3","create","glMatrix.ARRAY_TYPE","min","max","scale","normalize","y","z","len","sqrt","transformMat4","m","w","transformMat3","hypot","arguments","sub","DEDUP_DEFAULTS","keepUniqueNames","propertyTypes","PropertyType","ACCESSOR","MESH","TEXTURE","MATERIAL","SKIN","dedup","_options","options","propertyType","includes","logger","getLogger","indicesMap","attributeMap","inputMap","outputMap","meshes","listMeshes","forEach","mesh","listPrimitives","primitive","accessor","hashAccessor","animation","listAnimations","sampler","listSamplers","getInput","getOutput","group","hash","getType","getNormalized","getSparse","hashSet","detectDuplicates","duplicates","aData","BufferUtils","toView","equals","total","hashGroup","values","debug","input","output","dispose","dedupAccessors","root","textures","listTextures","bData","getName","aSize","getSize","bSize","entries","_ref","property","Root","dedupImages","materials","modifierCache","skip","hasModifier","_ref2","dedupMaterials","refs","listAccessors","index","numMeshes","uniqueMeshes","srcKeyItems","createPrimitiveKey","meshKey","targetMesh","ROOT","dedupMeshes","skins","listSkins","listJoints","_ref3","dedupSkins","primKeyItems","prop","cache","graph","visitedNodes","edgeQueue","listParentEdges","edge","pop","getAttributes","modifyChild","getChild","childEdge","listChildEdges","SRGB_PATTERN","getTextureColorSpace","texture","some","isColor","test","listTextureInfoByMaterial","results","traverse","textureInfoNames","Texture","TextureInfo","ExtensionProperty","listTextureSlots","slots","getParent","pruneSolidTextures","counter","_catch","maybeGetPixels","Infinity","width","height","EPS","getTextureFactor","factor","_texture$getSize","ColorUtils","convertSRGBToLinear","getURI","applyMaterialFactor","all","PRUNE_DEFAULTS","NODE","CAMERA","PRIMITIVE","PRIMITIVE_TARGET","ANIMATION","BUFFER","keepLeaves","keepAttributes","keepIndices","keepSolidTextures","prune","_temp3","treeShake","listBuffers","buffer","empty","info","str","type","DisposeCounter","listScenes","nodeTreeShake","listNodes","skin","camera","listCameras","indirectTreeShake","materialPrims","unused","listUnusedSemantics","listRequiredSemantics","pruneAttributes","prims","shiftTexCoords","pruneIndices","anim","channel","listChannels","getTargetNode","samplers","_temp2","_temp","disposed","key","p","AnimationChannel","listEdges","listChildren","isUsed","ptype","SCENE","setAttribute","setIndices","required","startsWith","semantics","edges","textureNames","getTexCoord","match","textureInfoList","texCoordSet","texCoordList","texCoordMap","texCoord","semanticMap","textureInfo","setTexCoord","updatePrim","srcSemantics","srcSemantic","uv","dstSemantic","slot","Material","setBaseColorFactor","getBaseColorFactor","setEmissiveFactor","mulVec3","getEmissiveFactor","setRoughnessFactor","getRoughnessFactor","setMetallicFactor","getMetallicFactor","warn","Tolerance","DEFAULT","TEXCOORD","COLOR","NORMAL","JOINTS","WEIGHTS","WELD_DEFAULTS","tolerance","toleranceNormal","overwrite","exhaustive","weld","expandWeldOptions","doc","transform","weldPrimitive","isPrimEmpty","c","_document","_prim","attr","numVertices","getBuffer","createAccessor","setBuffer","setType","Accessor","Type","SCALAR","_indexPrimitive","srcPosition","srcIndices","uniqueIndices","attributeTolerance","getAttributeTolerance","kv","posA","posB","grid","cellSize","POSITION","getElement","getGridKey","weldMap","writeMap","fill","srcVertexCount","dstVertexCount","cellKeys","getGridNeighborhoodKeys","cells","cellKey","neighbors","isBaseMatch","every","compareAttributes","isTargetMatch","dstIndicesCount","dstIndicesArray","getScalar","clone","srcAttr","swapAttributes","tmpIndicesArray","il","cleanPrimitive","_weldPrimitive","reorder","dstAttrArray","ArrayCtor","dstAttr","done","Uint8Array","el","setElement","_a","_b","getMinNormalized","getMaxNormalized","diff","bi","range","_semantic","CELL_OFFSETS","_p","round","PI","Number","EPSILON","transformPrimitive","matrix","skipIndices","_prim$getIndices","applyMatrix","normal","applyNormalMatrix","tangent","applyTangentMatrix","setScalar","reversePrimitiveWindingOrder","vector","createVec3","setNormalized","normalMatrix","fromMat4","b21","transpose","normalizeVec3","v3","v4","createVec4","transformMesh","srcPrim","dstPrim","srcTarget","dstTarget","parents","flatMap","attributes","srcAttribute","PrimitiveTarget","dstAttribute","attributeSkipIndices","primSkipIndices","IDENTITY","DEQUANTIZE_DEFAULTS","pattern","dequantizePrimitive","dequantizeAttribute","getComponentSize","DRACO_DEFAULTS","method","encodeSpeed","decodeSpeed","quantizePosition","quantizeNormal","quantizeColor","quantizeTexcoord","quantizeGeneric","quantizationVolume","properties","sceneBounds","getBounds","rootName","bboxMin","toPrecision","bboxMax","instances","glPrimitives","verts","meshIndices","meshAccessors","accessorToTypeLabel","targ","byteLength","modes","MeshPrimitiveModeLabels","mode","primitives","vertices","extensions","listExtensions","ref","alphaMode","getAlphaMode","doubleSided","getDoubleSided","resolution","ImageUtils","compression","dfd","readKTX","dataFormatDescriptor","colorModel","KHR_DF_MODEL_ETC1S","KHR_DF_MODEL_UASTC","uri","mimeType","gpuSize","getVRAMByteLength","minTime","maxTime","getMin","getMax","keyframes","channels","duration","NumericTypeLabels","Int32Array","Int16Array","Int8Array","INSTANCE_DEFAULTS","pruneUnusedNodes","nodes","unusedNodes","getCamera","getMesh","getSkin","nodeParent","hasVolume","getExtension","hasScale","getWorldScale","MathUtils","eq","createBatch","batchExtension","batchTranslation","batchRotation","batchScale","createInstancedMesh","JOIN_PRIMITIVE_DEFAULTS","skipValidation","joinPrimitives","templatePrim","remapList","indicesList","_getOrCreateIndices","undefined","createPrimitive","setMode","setMaterial","tplAttribute","AttributeArray","ComponentTypeToTypedArray","dstIndices","dstNextIndex","primIndex","indicesArray","primStartIndex","primNextIndex","_matrix","JOIN_DEFAULTS","keepMeshes","keepNamed","_joinLevel","groups","children","nodeIndex","dequantizeTransformableAttributes","isNamed","primMeshes","primNodes","dstNode","dstMesh","joinGroups","srcNodes","isSharedMesh","setMesh","dstMatrix","getMatrix","primNode","removePrimitive","hasSharedAttributes","_deepClonePrimitive","addPrimitive","getTextureChannelMask","mask","AlphaMode","OPAQUE","TextureChannel","A","REORDER_DEFAULTS","encoder","ready","plan","indicesToAttributes","indicesToMode","attributesToPrimitives","createLayoutPlan","unique","reorderMesh","sortPrimitiveWeights","isFinite","vertexCount","setCount","srcWeights","dstWeights","srcJoints","dstJoints","getVertexArray","setVertexArray","weights","joints","normList","typeList","isNormalizeSafe","templateAttribute","templateArray","componentType","normalized","normalizedComponentType","delta","decodeNormalizedInt","weightsSum","sum","intValue","encodeNormalizedInt","normalizePrimitiveWeights","vertexIndex","prefix","SIGNED_INT","TRANSLATION","ROTATION","SCALE","TargetPath","TRS_CHANNELS","QUANTIZE_DEFAULTS","quantizeWeight","normalizeWeights","quantize","patternTargets","nodeTransform","createExtension","KHRMeshQuantization","setRequired","getNodeTransform","bboxes","result","bbox","expandBounds","getPositionQuantizationVolume","transformMeshParents","transformMeshMaterials","quantizePrimitive","isTarget","bits","ctor","getQuantizationSettings","fromTransform","quantizeAttribute","volume","offset","transformMatrix","Node","animChannels","isAnimated","getTargetPath","isParentNode","setSkin","transformSkin","batch","setExtension","transformBatch","targetNode","createNode","setTargetNode","nodeMatrix","multiplyMat4","inverseBindMatrices","getInverseBindMatrices","ibm","setInverseBindMatrices","_batch$getAttribute","_batch$getAttribute2","_batch$getAttribute3","instanceTranslation","instanceRotation","instanceScale","tpl","T_IDENTITY","R_IDENTITY","S_IDENTITY","t","r","s","instanceMatrix","compose","decompose","getThicknessFactor","setThicknessFactor","signBits","quantBits","storageBits","BYTES_PER_ELEMENT","lo","hi","di","clamp","sign","setSparse","positions","relativePositions","flatBounds","relMin","relMax","tmpMin","tmpMax","xx","q","x2","xy","y2","xz","z2","yz","wx","wy","wz","sy","sz","yy","zz","sx","MESHOPT_DEFAULTS","level","_settle","pact","state","_Pact","bind","observer","o","prototype","onFulfilled","onRejected","_this","_isSettledPact","thenable","unweld","unweldAttribute","NORMALS_DEFAULTS","computeNormal","B","PALETTE_DEFAULTS","blockSize","encodeFloat","hex","encodeRGBA","convertLinearToSRGB","ceilPowerOfTwo","ceil","LN2","writeBlock","PARTITION_DEFAULTS","animations","createBufferURI","basename","existing","InterpolationInternal","lerp","v0","v1","vlerp","slerp","omega","cosom","sinom","scale0","scale1","ax","ay","az","aw","bx","by","bz","bw","acos","sin","getAngle","dotproduct","dot","EMPTY_ARRAY","RESAMPLE_DEFAULTS","resample","interpolation","tmp","valueNext","valuePrev","lastIndex","writeIndex","timePrev","time","timeNext","keep","sample","angle","toFloat32Array","fromFloat32Array","ComponentType","FLOAT","TypedArray","SEQUENCE_DEFAULTS","fps","SIMPLIFY_DEFAULTS","ratio","error","lockBorder","simplifyPrimitive","simplifier","positionArray","UNSIGNED_INT","targetCount","simplify","compactMesh","SPARSE_DEFAULTS","callback","TextureResizeFilter","TEXTURE_RESIZE_DEFAULTS","LANCZOS3","compressTexture","TEXTURE_COMPRESS_DEFAULTS","srcFormat","getFormat","dstFormat","targetFormat","srcMimeType","dstMimeType","_encodeWithSharp","_srcMimeType","encoderOptions","getFormatFromMimeType","quality","effort","lossless","nearLossless","instance","toFormat","resize","fit","kernel","resizeFilter","withoutEnlargement","_toView","toBuffer","_instance$toBuffer","call","_encodeWithNdarrayPixels","srcPixels","h","dstSize","dstPixels","ndarray","lanczos3","lanczos2","srcExtension","mimeTypeToExtension","dstExtension","dstURI","RegExp","setURI","TEXTURE_COMPRESS_SUPPORTED_FORMATS","SUPPORTED_MIME_TYPES","formats","format","split","srcMax","dstMax","TANGENTS_DEFAULTS","getNormalTexcoord","normalTextureInfo","getNormalTextureInfo","filterPrimitive","meshName","colorspace","vertexColorSpace","inputColorSpace","inputEncoding","toLowerCase","converted","sRGBToLinear","updatePrimitive","color","offsetNode","setTranslation","getTranslation","localMatrix","KHRDracoMeshCompression","setEncoderOptions","EncoderMethod","EDGEBREAKER","SEQUENTIAL","quantizationBits","TEX_COORD","GENERIC","joint","animated","hasJointParent","hasAnimatedParent","EXTMeshGPUInstancing","numBatches","numInstances","meshInstances","modifiedNodes","batchNode","needsTranslation","needsRotation","needsScale","getWorldTranslation","getWorldRotation","listProperties","R","G","textureEdge","EXTMeshoptCompression","QUANTIZE","FILTER","_temp4","specGlossExtension","tex","inputTextures","listExtensionsUsed","ext","extensionName","iorExtension","KHRMaterialsIOR","specExtension","KHRMaterialsSpecular","KHRMaterialsPBRSpecularGlossiness","_forOf","specGloss","specular","createSpecular","setSpecularFactor","setSpecularColorFactor","getSpecularFactor","getSpecularGlossinessTexture","getBaseColorTexture","getMetallicRoughnessTexture","getDiffuseFactor","createIOR","setIOR","diffuseTexture","getDiffuseTexture","setBaseColorTexture","getBaseColorTextureInfo","copy","getDiffuseTextureInfo","sgTexture","sgTextureInfo","getSpecularGlossinessTextureInfo","specularTexture","createTexture","setSpecularTexture","setSpecularColorTexture","getSpecularTextureInfo","getSpecularColorTextureInfo","glossinessFactor","getGlossinessFactor","metalRoughTexture","roughness","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","modified","faceNormal","_temp6","nextPaletteMaterialIndex","srcMaterial","materialKeyMap","padUV","materialIndices","keyCount","padWidth","dstMaterial","paletteMaterials","skipProps","suffix","padStart","setName","baseColorTexture","setMinFilter","MinFilter","NEAREST","setMagFilter","MagFilter","emissiveTexture","setEmissiveTexture","getEmissiveTextureInfo","metallicRoughnessTexture","paletteTexturePixels","metallicRoughness","image","emissive","materialKeys","materialProps","baseColor","metallic","visitedKeys","nextIndex","_temp5","existingURIs","meshIndex","isArray","createBuffer","primTarget","partitionMeshes","animIndex","partitionAnimations","accessorsVisited","srcAccessorCount","samplerTargetPaths","getSampler","samplerInterpolation","getInterpolation","tmpTimes","tmpValues","srcTimes","srcValues","dstTimes","byteOffset","dstValues","setInput","setOutput","dstAccessorCount","sequenceNodes","createAnimation","animBuffer","inputArray","outputArray","VEC3","createAnimationSampler","setInterpolation","AnimationSampler","Interpolation","STEP","createAnimationChannel","setTargetPath","setSampler","addSampler","addChannel","modifiedCount","base","nonZeroCount","sparse","generateTangents","attributeIDs","tangentCache","meshPrimitives","texcoordSemantic","texcoord","positionID","uuid","normalID","texcoordID","prevTangent","attributeHash","tangentBuffer","tangentArray","patternRe","formatsRe","slotsRe","textureIndex","textureLabel","srcByteLength","dstByteLength","flag","webpExtension","EXTTextureWebP","avifExtension","EXTTextureAVIF","_exit","_result","_options$slots","srcSize","message","_setImage","_savePixels","unlit","KHRMaterialsUnlit","createUnlit"],"mappings":"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"}