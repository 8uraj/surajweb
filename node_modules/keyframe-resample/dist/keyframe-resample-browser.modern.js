var InterpolationInternal;

(function (InterpolationInternal) {
  InterpolationInternal[InterpolationInternal["STEP"] = 0] = "STEP";
  InterpolationInternal[InterpolationInternal["LERP"] = 1] = "LERP";
  InterpolationInternal[InterpolationInternal["SLERP"] = 2] = "SLERP";
})(InterpolationInternal || (InterpolationInternal = {}));

const TO_INTERPOLATION_INTERNAL = {
  step: InterpolationInternal.STEP,
  lerp: InterpolationInternal.LERP,
  slerp: InterpolationInternal.SLERP
};
const EPSILON = 0.000001;

/* Implementation */

function resampleDebug(input, output, interpolation, tolerance = 1e-4) {
  const elementSize = output.length / input.length;
  const tmp = new Array(elementSize).fill(0);
  const value = new Array(elementSize).fill(0);
  const valueNext = new Array(elementSize).fill(0);
  const valuePrev = new Array(elementSize).fill(0);
  const lastIndex = input.length - 1;
  let writeIndex = 1;

  for (let i = 1; i < lastIndex; ++i) {
    const timePrev = input[writeIndex - 1];
    const time = input[i];
    const timeNext = input[i + 1];
    const t = (time - timePrev) / (timeNext - timePrev);
    let keep = false; // Remove unnecessary adjacent keyframes.

    if (time !== timeNext && (i !== 1 || time !== input[0])) {
      getElement(output, writeIndex - 1, valuePrev);
      getElement(output, i, value);
      getElement(output, i + 1, valueNext);

      if (interpolation === 'slerp') {
        // Prune keyframes colinear with prev/next keyframes.
        const sample = slerp(tmp, valuePrev, valueNext, t);
        const angle = getAngle(valuePrev, value) + getAngle(value, valueNext);
        keep = !eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;
      } else if (interpolation === 'lerp') {
        // Prune keyframes colinear with prev/next keyframes.
        const sample = vlerp(tmp, valuePrev, valueNext, t);
        keep = !eq(value, sample, tolerance);
      } else if (interpolation === 'step') {
        // Prune keyframes identical to prev/next keyframes.
        keep = !eq(value, valuePrev) || !eq(value, valueNext);
      }
    } // In-place compaction.


    if (keep) {
      if (i !== writeIndex) {
        input[writeIndex] = input[i];
        setElement(output, writeIndex, getElement(output, i, tmp));
      }

      writeIndex++;
    }
  } // Flush last keyframe (compaction looks ahead).


  if (lastIndex > 0) {
    input[writeIndex] = input[lastIndex];
    setElement(output, writeIndex, getElement(output, lastIndex, tmp));
    writeIndex++;
  }

  return writeIndex;
}
/* Utilities */

function getElement(array, index, target) {
  for (let i = 0, elementSize = target.length; i < elementSize; i++) {
    target[i] = array[index * elementSize + i];
  }

  return target;
}

function setElement(array, index, value) {
  for (let i = 0, elementSize = value.length; i < elementSize; i++) {
    array[index * elementSize + i] = value[i];
  }
}

function eq(a, b, tolerance = 0) {
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i++) {
    if (Math.abs(a[i] - b[i]) > tolerance) {
      return false;
    }
  }

  return true;
}

function lerp(v0, v1, t) {
  return v0 * (1 - t) + v1 * t;
}

function vlerp(out, a, b, t) {
  for (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);

  return out;
} // From gl-matrix.


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  let bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  let omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}

function getAngle(a, b) {
  const dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/** WASM loader for Web environments. */
const wasm = /* #__PURE__ */fetch( /* #__PURE__ */new URL('./release.wasm', import.meta.url));

// SETUP
///////////////////////////////////////////////////////////////////////////////

let exports;
const ready = /* #__PURE__ */new Promise(async (resolve, reject) => {
  try {
    const module = await WebAssembly.compile(await wasm);
    exports = await instantiate(module, {});
    resolve();
  } catch (e) {
    reject(e);
  }
});

async function instantiate(module, imports = {}) {
  const instance = await WebAssembly.instantiate(module, {
    env: Object.assign(Object.create(globalThis), {}, {
      abort: __abort
    })
  });
  return instance.exports;
} ///////////////////////////////////////////////////////////////////////////////
// PUBLIC API
///////////////////////////////////////////////////////////////////////////////


const CHUNK_SIZE = 1024; // The first and last keyframes cannot be removed in any given step, but we need to
// somehow remove keyframes on chunk boundaries. So after processing each chunk,
// we copy its last two keyframes in front of the next chunk, and run from there.
//
// 游릴 拘럺잺 拘럺잺 拘럺잺 拘럺잺 拘럺잺                  // chunk 1, original
// 游릴 拘럺잺 游릳 游린                       // chunk 1, resampled
//            游릳 游린 游릴 拘럺잺 拘럺잺 拘럺잺       // chunk 2, original
//            游릳 游릴 拘럺잺 拘럺잺            // chunk 2, resampled
// ...

function resample(input, output, interpolation, tolerance = 1e-4) {
  __assert(!!exports, 'Await "ready" before using module.');

  __assert(input instanceof Float32Array, 'Missing Float32Array input.');

  __assert(output instanceof Float32Array, 'Missing Float32Array output.');

  const outputSize = output.length / input.length;

  __assert(Number.isInteger(outputSize), 'Invalid input/output counts.');

  __assert(interpolation in TO_INTERPOLATION_INTERNAL, 'Invalid interpolation.');

  __assert(Number.isFinite(tolerance), 'Invalid tolerance');

  const interpVal = TO_INTERPOLATION_INTERNAL[interpolation];
  const srcCount = input.length;
  let dstCount = 0;

  for (let chunkStart = 0; chunkStart < input.length; chunkStart += CHUNK_SIZE) {
    const chunkCount = Math.min(srcCount - chunkStart, CHUNK_SIZE); // Allocate a two-keyframe prefix for all chunks after the first.

    const prefixCount = chunkStart > 0 ? 2 : 0;
    const chunkInput = new Float32Array(input.buffer, input.byteOffset + (chunkStart - prefixCount) * Float32Array.BYTES_PER_ELEMENT, chunkCount + prefixCount);
    const chunkOutput = new Float32Array(output.buffer, output.byteOffset + (chunkStart - prefixCount) * outputSize * Float32Array.BYTES_PER_ELEMENT, (chunkCount + prefixCount) * outputSize); // Copy prefix to start of next chunk.

    if (prefixCount > 0) {
      input.copyWithin(chunkStart - prefixCount, dstCount - prefixCount, dstCount);
      output.copyWithin((chunkStart - prefixCount) * outputSize, (dstCount - prefixCount) * outputSize, dstCount * outputSize);
    }

    const inputPtr = __retain(__lowerStaticArray(chunkInput, 4, 2));

    const outputPtr = __retain(__lowerStaticArray(chunkOutput, 4, 2));

    try {
      exports.__setArgumentsLength(4);

      const count = exports.resample(inputPtr, outputPtr, interpVal, tolerance) >>> 0;
      dstCount -= prefixCount;

      __liftStaticArray(inputPtr, input, dstCount, count);

      __liftStaticArray(outputPtr, output, dstCount * outputSize, count * outputSize);

      dstCount += count;
    } finally {
      __release(inputPtr);

      __release(outputPtr);

      exports.__collect();
    }
  } // console.log(`Memory: ${exports.memory.buffer.byteLength} bytes`);


  return dstCount;
} ///////////////////////////////////////////////////////////////////////////////
// INTERNAL
///////////////////////////////////////////////////////////////////////////////

function __assert(cond, msg) {
  if (!cond) throw new Error(msg);
}

function __retain(ptr) {
  exports.__pin(ptr);

  return ptr;
}

function __release(ptr) {
  exports.__unpin(ptr);

  return ptr;
}

function __liftString(ptr) {
  if (!ptr) return null;
  const end = ptr + new Uint32Array(exports.memory.buffer)[ptr - 4 >>> 2] >>> 1,
        memoryU16 = new Uint16Array(exports.memory.buffer);
  let start = ptr >>> 1,
      string = '';

  while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));

  return string + String.fromCharCode(...memoryU16.subarray(start, end));
}

function __lowerStaticArray(values, id, align) {
  const ptr = exports.__pin(exports.__new(values.length << align, id)) >>> 0;
  new Float32Array(exports.memory.buffer, ptr, values.length).set(values);

  exports.__unpin(ptr);

  return ptr;
}

function __liftStaticArray(ptr, values, offset, count) {
  values.set(new Float32Array(exports.memory.buffer, ptr, count), offset);
}

function __abort(messagePtr, fileNamePtr, lineNumber, columnNumber) {
  const message = __liftString(messagePtr >>> 0);

  const fileName = __liftString(fileNamePtr >>> 0);

  lineNumber = lineNumber >>> 0;
  columnNumber = columnNumber >>> 0;

  (() => {
    throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);
  })();
}

export { ready, resample, resampleDebug };
//# sourceMappingURL=keyframe-resample-browser.modern.js.map
