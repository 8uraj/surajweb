var InterpolationInternal;

(function (InterpolationInternal) {
  InterpolationInternal[InterpolationInternal["STEP"] = 0] = "STEP";
  InterpolationInternal[InterpolationInternal["LERP"] = 1] = "LERP";
  InterpolationInternal[InterpolationInternal["SLERP"] = 2] = "SLERP";
})(InterpolationInternal || (InterpolationInternal = {}));

const TO_INTERPOLATION_INTERNAL = {
  step: InterpolationInternal.STEP,
  lerp: InterpolationInternal.LERP,
  slerp: InterpolationInternal.SLERP
};
const EPSILON = 0.000001;

/* Implementation */

function resampleDebug(input, output, interpolation, tolerance = 1e-4) {
  const elementSize = output.length / input.length;
  const tmp = new Array(elementSize).fill(0);
  const value = new Array(elementSize).fill(0);
  const valueNext = new Array(elementSize).fill(0);
  const valuePrev = new Array(elementSize).fill(0);
  const lastIndex = input.length - 1;
  let writeIndex = 1;

  for (let i = 1; i < lastIndex; ++i) {
    const timePrev = input[writeIndex - 1];
    const time = input[i];
    const timeNext = input[i + 1];
    const t = (time - timePrev) / (timeNext - timePrev);
    let keep = false; // Remove unnecessary adjacent keyframes.

    if (time !== timeNext && (i !== 1 || time !== input[0])) {
      getElement(output, writeIndex - 1, valuePrev);
      getElement(output, i, value);
      getElement(output, i + 1, valueNext);

      if (interpolation === 'slerp') {
        // Prune keyframes colinear with prev/next keyframes.
        const sample = slerp(tmp, valuePrev, valueNext, t);
        const angle = getAngle(valuePrev, value) + getAngle(value, valueNext);
        keep = !eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;
      } else if (interpolation === 'lerp') {
        // Prune keyframes colinear with prev/next keyframes.
        const sample = vlerp(tmp, valuePrev, valueNext, t);
        keep = !eq(value, sample, tolerance);
      } else if (interpolation === 'step') {
        // Prune keyframes identical to prev/next keyframes.
        keep = !eq(value, valuePrev) || !eq(value, valueNext);
      }
    } // In-place compaction.


    if (keep) {
      if (i !== writeIndex) {
        input[writeIndex] = input[i];
        setElement(output, writeIndex, getElement(output, i, tmp));
      }

      writeIndex++;
    }
  } // Flush last keyframe (compaction looks ahead).


  if (lastIndex > 0) {
    input[writeIndex] = input[lastIndex];
    setElement(output, writeIndex, getElement(output, lastIndex, tmp));
    writeIndex++;
  }

  return writeIndex;
}
/* Utilities */

function getElement(array, index, target) {
  for (let i = 0, elementSize = target.length; i < elementSize; i++) {
    target[i] = array[index * elementSize + i];
  }

  return target;
}

function setElement(array, index, value) {
  for (let i = 0, elementSize = value.length; i < elementSize; i++) {
    array[index * elementSize + i] = value[i];
  }
}

function eq(a, b, tolerance = 0) {
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i++) {
    if (Math.abs(a[i] - b[i]) > tolerance) {
      return false;
    }
  }

  return true;
}

function lerp(v0, v1, t) {
  return v0 * (1 - t) + v1 * t;
}

function vlerp(out, a, b, t) {
  for (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);

  return out;
} // From gl-matrix.


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  let bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  let omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}

function getAngle(a, b) {
  const dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/** WASM loader using an inline Data URI. */
const wasm = /* #__PURE__ */fetch('data:application/wasm;base64' + "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");

// SETUP
///////////////////////////////////////////////////////////////////////////////

let exports;
const ready = /* #__PURE__ */new Promise(async (resolve, reject) => {
  try {
    const module = await WebAssembly.compile(await wasm);
    exports = await instantiate(module, {});
    resolve();
  } catch (e) {
    reject(e);
  }
});

async function instantiate(module, imports = {}) {
  const instance = await WebAssembly.instantiate(module, {
    env: Object.assign(Object.create(globalThis), {}, {
      abort: __abort
    })
  });
  return instance.exports;
} ///////////////////////////////////////////////////////////////////////////////
// PUBLIC API
///////////////////////////////////////////////////////////////////////////////


const CHUNK_SIZE = 1024; // The first and last keyframes cannot be removed in any given step, but we need to
// somehow remove keyframes on chunk boundaries. So after processing each chunk,
// we copy its last two keyframes in front of the next chunk, and run from there.
//
// 🟩 ⬜️ ⬜️ ⬜️ ⬜️ ⬜️                  // chunk 1, original
// 🟩 ⬜️ 🟨 🟥                       // chunk 1, resampled
//            🟨 🟥 🟩 ⬜️ ⬜️ ⬜️       // chunk 2, original
//            🟨 🟩 ⬜️ ⬜️            // chunk 2, resampled
// ...

function resample(input, output, interpolation, tolerance = 1e-4) {
  __assert(!!exports, 'Await "ready" before using module.');

  __assert(input instanceof Float32Array, 'Missing Float32Array input.');

  __assert(output instanceof Float32Array, 'Missing Float32Array output.');

  const outputSize = output.length / input.length;

  __assert(Number.isInteger(outputSize), 'Invalid input/output counts.');

  __assert(interpolation in TO_INTERPOLATION_INTERNAL, 'Invalid interpolation.');

  __assert(Number.isFinite(tolerance), 'Invalid tolerance');

  const interpVal = TO_INTERPOLATION_INTERNAL[interpolation];
  const srcCount = input.length;
  let dstCount = 0;

  for (let chunkStart = 0; chunkStart < input.length; chunkStart += CHUNK_SIZE) {
    const chunkCount = Math.min(srcCount - chunkStart, CHUNK_SIZE); // Allocate a two-keyframe prefix for all chunks after the first.

    const prefixCount = chunkStart > 0 ? 2 : 0;
    const chunkInput = new Float32Array(input.buffer, input.byteOffset + (chunkStart - prefixCount) * Float32Array.BYTES_PER_ELEMENT, chunkCount + prefixCount);
    const chunkOutput = new Float32Array(output.buffer, output.byteOffset + (chunkStart - prefixCount) * outputSize * Float32Array.BYTES_PER_ELEMENT, (chunkCount + prefixCount) * outputSize); // Copy prefix to start of next chunk.

    if (prefixCount > 0) {
      input.copyWithin(chunkStart - prefixCount, dstCount - prefixCount, dstCount);
      output.copyWithin((chunkStart - prefixCount) * outputSize, (dstCount - prefixCount) * outputSize, dstCount * outputSize);
    }

    const inputPtr = __retain(__lowerStaticArray(chunkInput, 4, 2));

    const outputPtr = __retain(__lowerStaticArray(chunkOutput, 4, 2));

    try {
      exports.__setArgumentsLength(4);

      const count = exports.resample(inputPtr, outputPtr, interpVal, tolerance) >>> 0;
      dstCount -= prefixCount;

      __liftStaticArray(inputPtr, input, dstCount, count);

      __liftStaticArray(outputPtr, output, dstCount * outputSize, count * outputSize);

      dstCount += count;
    } finally {
      __release(inputPtr);

      __release(outputPtr);

      exports.__collect();
    }
  } // console.log(`Memory: ${exports.memory.buffer.byteLength} bytes`);


  return dstCount;
} ///////////////////////////////////////////////////////////////////////////////
// INTERNAL
///////////////////////////////////////////////////////////////////////////////

function __assert(cond, msg) {
  if (!cond) throw new Error(msg);
}

function __retain(ptr) {
  exports.__pin(ptr);

  return ptr;
}

function __release(ptr) {
  exports.__unpin(ptr);

  return ptr;
}

function __liftString(ptr) {
  if (!ptr) return null;
  const end = ptr + new Uint32Array(exports.memory.buffer)[ptr - 4 >>> 2] >>> 1,
        memoryU16 = new Uint16Array(exports.memory.buffer);
  let start = ptr >>> 1,
      string = '';

  while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));

  return string + String.fromCharCode(...memoryU16.subarray(start, end));
}

function __lowerStaticArray(values, id, align) {
  const ptr = exports.__pin(exports.__new(values.length << align, id)) >>> 0;
  new Float32Array(exports.memory.buffer, ptr, values.length).set(values);

  exports.__unpin(ptr);

  return ptr;
}

function __liftStaticArray(ptr, values, offset, count) {
  values.set(new Float32Array(exports.memory.buffer, ptr, count), offset);
}

function __abort(messagePtr, fileNamePtr, lineNumber, columnNumber) {
  const message = __liftString(messagePtr >>> 0);

  const fileName = __liftString(fileNamePtr >>> 0);

  lineNumber = lineNumber >>> 0;
  columnNumber = columnNumber >>> 0;

  (() => {
    throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);
  })();
}

export { ready, resample, resampleDebug };
