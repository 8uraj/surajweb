var ndarray = require('ndarray');
var ops = require('ndarray-ops');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var ndarray__default = /*#__PURE__*/_interopDefaultLegacy(ndarray);
var ops__default = /*#__PURE__*/_interopDefaultLegacy(ops);

function getPixelsInternal(buffer, mimeType) {
  // Warn for Data URIs, URLs, and file paths. Support removed in v3.
  if (!(buffer instanceof Uint8Array)) {
    throw new Error('[ndarray-pixels] Input must be Uint8Array or Buffer.');
  }
  var blob = new Blob([buffer], {
    type: mimeType
  });
  var path = URL.createObjectURL(blob);
  // Decode image with Canvas API.
  return new Promise(function (resolve, reject) {
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function () {
      URL.revokeObjectURL(path);
      var canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      var context = canvas.getContext('2d');
      context.drawImage(img, 0, 0);
      var pixels = context.getImageData(0, 0, img.width, img.height);
      resolve(ndarray__default["default"](new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4 * img.width, 1], 0));
    };
    img.onerror = function (err) {
      URL.revokeObjectURL(path);
      reject(err);
    };
    img.src = path;
  });
}

function putPixelData(array, data, frame) {
  if (frame === void 0) {
    frame = -1;
  }
  if (array.shape.length === 4) {
    return putPixelData(array.pick(frame), data, 0);
  } else if (array.shape.length === 3) {
    if (array.shape[2] === 3) {
      ops__default["default"].assign(ndarray__default["default"](data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), array);
      ops__default["default"].assigns(ndarray__default["default"](data, [array.shape[0] * array.shape[1]], [4], 3), 255);
    } else if (array.shape[2] === 4) {
      ops__default["default"].assign(ndarray__default["default"](data, [array.shape[0], array.shape[1], 4], [4, array.shape[0] * 4, 1]), array);
    } else if (array.shape[2] === 1) {
      ops__default["default"].assign(ndarray__default["default"](data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), ndarray__default["default"](array.data, [array.shape[0], array.shape[1], 3], [array.stride[0], array.stride[1], 0], array.offset));
      ops__default["default"].assigns(ndarray__default["default"](data, [array.shape[0] * array.shape[1]], [4], 3), 255);
    } else {
      throw new Error('[ndarray-pixels] Incompatible array shape.');
    }
  } else if (array.shape.length === 2) {
    ops__default["default"].assign(ndarray__default["default"](data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), ndarray__default["default"](array.data, [array.shape[0], array.shape[1], 3], [array.stride[0], array.stride[1], 0], array.offset));
    ops__default["default"].assigns(ndarray__default["default"](data, [array.shape[0] * array.shape[1]], [4], 3), 255);
  } else {
    throw new Error('[ndarray-pixels] Incompatible array shape.');
  }
  return data;
}

var savePixelsInternal = function savePixelsInternal(pixels, mimeType, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    // Create HTMLCanvasElement and write pixel data.
    var canvas = document.createElement('canvas');
    canvas.width = pixels.shape[0];
    canvas.height = pixels.shape[1];
    var context = canvas.getContext('2d');
    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    putPixelData(pixels, imageData.data);
    context.putImageData(imageData, 0, 0);
    var quality = options.quality ? options.quality / 100 : undefined;
    // Encode to target format.
    switch (mimeType) {
      case 'image/jpeg':
        return Promise.resolve(streamCanvas(canvas, 'image/jpeg', quality));
      default:
        return Promise.resolve(streamCanvas(canvas, mimeType));
    }
  } catch (e) {
    return Promise.reject(e);
  }
};
/** Creates readable stream from given HTMLCanvasElement and options. */
function streamCanvas(canvas, mimeType, quality) {
  return new Promise(function (resolve, reject) {
    canvas.toBlob(function (blob) {
      try {
        var _temp = function () {
          if (blob) {
            return Promise.resolve(blob.arrayBuffer()).then(function (_blob$arrayBuffer) {
              resolve(new Uint8Array(_blob$arrayBuffer));
            });
          } else {
            reject(new Error('[ndarray-pixels] Failed to canvas.toBlob().'));
          }
        }();
        return Promise.resolve(_temp && _temp.then ? _temp.then(function () {}) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    }, mimeType, quality);
  });
}

/**
 * Decodes image data to an `ndarray`.
 *
 * MIME type is optional when given a path or URL, and required when given a Uint8Array.
 *
 * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with
 * the necessary support in Canvas 2D.
 *
 * @param data
 * @param mimeType `image/jpeg`, `image/png`, etc.
 * @returns
 */
/**
 * Encodes an `ndarray` as image data in the given format.
 *
 * If the source `ndarray` was constructed manually with default stride, use
 * `ndarray.transpose(1, 0)` to reshape it and ensure an identical result from getPixels(). For an
 * ndarray created by getPixels(), this isn't necessary.
 *
 * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with
 * the necessary support in Canvas 2D.
 *
 * @param pixels ndarray of shape W x H x 4.
 * @param mimeType `image/jpeg`, `image/png`, etc.
 * @returns
 */
var savePixels = function savePixels(pixels, mimeType) {
  try {
    return Promise.resolve(savePixelsInternal(pixels, mimeType));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getPixels = function getPixels(data, mimeType) {
  try {
    return Promise.resolve(getPixelsInternal(data, mimeType));
  } catch (e) {
    return Promise.reject(e);
  }
};

exports.getPixels = getPixels;
exports.savePixels = savePixels;
//# sourceMappingURL=ndarray-pixels-browser.cjs.map
